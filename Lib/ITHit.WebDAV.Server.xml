<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ITHit.WebDAV.Server</name>
    </assembly>
    <members>
        <member name="T:ITHit.WebDAV.Server.Acl.AceType">
            <summary>
            Type of <see cref="T:ITHit.WebDAV.Server.Acl.ReadAce"/> or <see cref="T:ITHit.WebDAV.Server.Acl.WriteAce"/> record.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Grant">
            <summary>
            Grants permissions.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Deny">
            <summary>
            Denies permissions.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.AclRestriction">
            <summary>
            Defines the types of ACLs supported by the server, to avoid clients needlessly getting
            errors.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.GrantOnly">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges"/> are not allowed.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.NoInvert">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges"/> == false are not supported.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.RequiredPrincipals">
            <summary>
            Indicates which principals are required to be present in ACL.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync">
            <summary>
            Interface to be implemented by hierarchy items that support setting permissions.
            </summary>
            <remarks>
            This interface is optional on hierarchy items. However, to support iOS and OS X CalDAV and CardDAV 
            clients this interface must be implemented. iOS and OS X CalDAV and CardDAV clients request 
            current-user-principal and principal-URL properties and would not connect to server if no proper responce 
            is provided.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.IHierarchyItemAsync">
            <summary>
            Represents one item (file, folder) in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods common to all WebDAV folders and files.
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Created"/> and <see cref="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Modified"/> properties must return Universal Coordinated Time (UTC).
            <see cref="!:GetProperties"/> and <see cref="!:UpdateProperties"/> are called when WebDAV client is reading, adding,
            updating or deleting properties.  This interface also provides methods for managing hierarchy: moving, copying
            and deleting WebDAV items.  See <see cref="!:CopyTo"/>, <see cref="!:MoveTo"/> and <see cref="!:Delete"/> methods.
            Your file items must implement <see cref="!:IFile"/> interface, folder items - <see cref="!:IFolder"/> interface.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.CopyToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Creates a copy of this item with a new name in the destination folder.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="deep">Indicates whether to copy entire subtree.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">Destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <remarks>
            <para>
            If error occurred while copying file located in a subtree, the server 
            should try to continue copy operation and copy all other items. In this case 
            you must add that error <paramref name="multistatus"/> container.
            </para>
            <para>
            A CopyTo method invocation must not copy any locks active on the source item.
            However, if this method copies the item into a folder that has a deep lock,
            then the destination item must be added to the lock.
            </para>
            </remarks>
            <example>
            Example of <c>CopyTo</c> implementation for WebDAV Class 2 server:
            <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para><code><![CDATA[public override void CopyTo(IItemCollection destFolder, string destName, bool deep, MultistatusException multistatus)
{
    context.FileOperation(
        () => copyToInternal(destFolder, destName, multistatus));
}

private void copyToInternal(IItemCollection folder, string destName, MultistatusException multistatus)
{
    var targetFolder = (DavFolder)folder;

    if (targetFolder == null || !Directory.Exists(targetFolder.GetFullPath()))
    {
        throw new DavException("Target directory doesn't exist", DavStatus.CONFLICT);
    }

    var newDirPath = System.IO.Path.Combine(targetFolder.GetFullPath(), destName);
    var targetPath = targetFolder.Path + EncodeUtil.EncodeUrlPart(destName);

    //If an item with the same name exists - remove it.
    try
    {
        IHierarchyItem item = context.GetHierarchyItem(targetPath);
        if (item != null)
            item.Delete(multistatus);
    }
    catch (DavException ex)
    {
        //Report error with other item to client.
        multistatus.AddInnerException(targetPath, ex);
        return;
    }

    //Copy the file.
    try
    {
        File.Copy(fileSystemInfo.FullName, newDirPath);
        DeleteStream(newDirPath, "Locks");
    }
    catch (UnauthorizedAccessException)
    {
        //Fail
        var ex = new NeedPrivilegesException("Not enough privileges");
        ex.AddRequiredPrivilege(GetParent().Path, Privilege.Bind);
        throw ex;
    }
}
]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.MoveToAsync(ITHit.WebDAV.Server.IItemCollectionAsync,System.String,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Moves this item to the destination folder under a new name.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The source or the destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <remarks>
            <papa>
            If the item is locked the server must not move any locks with the item. However, items must be added to an
            existing lock at the destination.
            </papa>
            </remarks>
            <example>
            Example of <c>MoveTo</c> implementation for WebDAV Class 2 server:
            <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para><code><![CDATA[public override void MoveTo(IItemCollection destFolder, string destName, MultistatusException multistatus)
{
    RequireHasToken();
    context.FileOperation(
        () => moveToInternal(destFolder, destName, multistatus));
}

private void moveToInternal(IItemCollection folder, string destName, MultistatusException multistatus)
{
    var targetFolder = (DavFolder)folder;

    if (targetFolder == null || !Directory.Exists(targetFolder.GetFullPath()))
    {
        throw new DavException("Target directory doesn't exist", DavStatus.CONFLICT);
    }

    var newDirPath = System.IO.Path.Combine(targetFolder.GetFullPath(), destName);
    var targetPath = targetFolder.Path + EncodeUtil.EncodeUrlPart(destName);

    //If an item with the same name exists in target directory - remove it.
    try
    {
        IHierarchyItem item = context.GetHierarchyItem(targetPath);
        if (item != null)
            item.Delete(multistatus);
    }
    catch (DavException ex)
    {
        //Report exception to client and continue with other items by returning from recursion.
        multistatus.AddInnerException(targetPath, ex);
        return;
    }

    //Move the file.
    try
    {
        File.Move(fileSystemInfo.FullName, newDirPath);
    }
    catch (UnauthorizedAccessException)
    {
        //Exception occurred with the item for which MoveTo was called - fail the operation.
        var ex = new NeedPrivilegesException("Not enough privileges");
        ex.AddRequiredPrivilege(targetPath, Privilege.Bind);
        ex.AddRequiredPrivilege(GetParent().Path, Privilege.Unbind);
        throw ex;
    }
}
]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.DeleteAsync(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Deletes this item.
            </summary>
            <param name="multistatus">If some items fail to delete but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item or its parent was locked and client did not provide lock
            token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree
            and whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <example>
            Example of <c>Delete</c> implementation for WebDAV Class 2 server:
            <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para><code><![CDATA[public override void Delete(MultistatusException multistatus)
{
    RequireHasToken();
    context.FileOperation(
        this,
        () => fileSystemInfo.Delete(),
        Privilege.Unbind);
}
]]></code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)">
            <summary>
            Gets values of all properties or selected properties for this item.
            </summary>
            <param name="props">
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> with property names which values are requested by WebDAV client. 
            If a property does not exist for this hierarchy item then the property value shall not be returned.
            </param>
            <param name="allprop">
            If it is <c>true</c> it means that besides properties listed in <paramref name="props"/> you need to 
            return all properties you think may be useful to client.
            </param>
            <returns>
            Enumerable with property values.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<PropertyValue> GetProperties(IList<PropertyName> names, bool allprop)
{
    if (allprop)
    {
        // get all properties
        return getPropertyValues();
    }

    //Get requeste property values.
    return getPropertyValues().Where(property => names.Contains(property.QualifiedName));
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.GetPropertyNamesAsync">
            <summary>
            Gets names of all properties for this item.
            </summary>
            <returns>
            Enumerable with available property names.
            </returns>
            <remarks>
            <para>Most WebDAV clients never request list of property names, so your implementation can just return
            empty enumerable.</para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<PropertyName> GetPropertyNames()
{
    return getPropertyValues().Select(p => p.QualifiedName);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItemAsync.UpdatePropertiesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds, modifies and removes properties for this item.
            </summary>
            <param name="setProps">List of properties to be set.</param>
            <param name="delProps">List of property names to be removed. Properties that don't exist shall be skipped.</param>
            <param name="multistatus">The standard requires this operation to be transactional.
            If some properties fail to update but there is no possibility to rollback the transaction
            in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/>, add
            information about the error into <paramref name="multistatus"/> 
            using <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)"/>.
            In this case engine will report correct statuses for all properties at least
            (although this is against standard).
            </param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked and client
            did not provide lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">
            The exception shall contain statuses for all properties that
            failed to update.
            Typical property error statuses:
            <list type="bullet">
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> - the client has provided a value
            whose semantics are not appropriate for the property, this includes
            trying to set read-only properties.
            </description>
            </item>
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY"/> - indicates this action would
            have succeeded if it were not for the conflict with
            updating/removing some other property.
            </description>
            </item>
            </list>
            </exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <c>UpdateProperties</c> implementation you will create,
            modify and delete item properties.
            Single property update request may invoke following methods of single item which update properties:
            <list type="bullet">
                <item><see cref="!:IAclHierarchyItem.SetOwner"/></item>
                <item><see cref="!:IAclHierarchyItem.SetGroup"/></item>
                <item><see cref="!:IVersionableItem.SetAutoVersion"/></item>
                <item><see cref="!:IDeltaVItem.SetComment"/></item>
                <item><see cref="!:IDeltaVItem.SetCreatorDisplayName"/></item>
                <item><see cref="!:IPrincipal.SetGroupMembers"/></item>
                <item><see cref="!:IHierarchyItem.UpdateProperties"/></item>
            </list>
            Engine will update properties (call these methods) one by one unless exception is thrown.
            If an exception is thrown during a property update engine will report all remaining properties
            as failed with status <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY"/>
            </para>
            <para>
            The standard requires that request which updates properties is atomic (PROPPATCH).
            If your storage supports transactions then atomicity requirement can be implemented
            by committing or rollbacking the transaction in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/>.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual void UpdateProperties(
    IList<PropertyValue> setProps,
    IList<PropertyName> delProps,
    MultistatusException multistatus)
{
    RequireHasToken();
    foreach (PropertyValue propToSet in setProps)
    {
        // Microsoft Mini-redirector may update file creation date, modification date and access time passing properties:
        // <Win32CreationTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:15:34 GMT</Win32CreationTime>
        // <Win32LastModifiedTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastModifiedTime>
        // <Win32LastAccessTime xmlns="urn:schemas-microsoft-com:">Thu, 28 Mar 2013 20:36:24 GMT</Win32LastAccessTime>
        // In this case update creation and modified date in your storage or do not save this properties at all, otherwise 
        // Windows Explorer will display creation and modification date from this props and it will differ from the values 
        // in the Created and Modified fields in your storage 
        if (propToSet.QualifiedName.Namespace == "urn:schemas-microsoft-com:")
        {
            if (propToSet.QualifiedName.Name == "Win32CreationTime")
            {
                fileSystemInfo.CreationTimeUtc =
                    DateTime.Parse(propToSet.Value, new System.Globalization.CultureInfo("en-US")).ToUniversalTime();
            }
            else if (propToSet.QualifiedName.Name == "Win32LastModifiedTime")
            {
                fileSystemInfo.LastWriteTimeUtc =
                    DateTime.Parse(propToSet.Value, new System.Globalization.CultureInfo("en-US")).ToUniversalTime();
            }
        }
        else
        {
            var existingProp = getPropertyValues().FirstOrDefault(p => p.QualifiedName == propToSet.QualifiedName);

            if (existingProp != null)
            {
                existingProp.Value = propToSet.Value;
            }
            else
            {
                getPropertyValues().Add(propToSet);
            }
        }
    }

    getPropertyValues().RemoveAll(prop => delProps.Contains(prop.QualifiedName));

    context.FileOperation(
        this,
        () => RewriteStream("Properties", propertyValues),
        Privilege.Write);

    // You should not update modification date/time here. Mac OS X Finder expects that properties update do not change the file modification date.
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Name">
            <summary>
            Gets the name of the item in repository.
            </summary>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public string Name
{
    get { return fileSystemInfo.Name; }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Created">
            <summary>
            Gets the creation date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public DateTime Created
{
    get { return fileSystemInfo.CreationTimeUtc; }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Modified">
            <summary>
            Gets the last modification date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
            <remarks>
            Value of this property must change only when content of the item changes. It must not change when item is locked or
            unlocked or properties modified. In particular Mac OS relies on such behavior.
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public DateTime Modified
{
    get { return fileSystemInfo.LastWriteTimeUtc; }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Path">
            <summary>
            Unique item path in the repository relative to storage root.
            </summary>
            <remarks>
            <para>
            The URL returned by this property is relative to storage root.
            If your server root is located at http://example.webdavsystem.com:8080/myserver/ and the item URL is
            http://example.webdavsystem.com:8080/myserver/myfolder/myitem.doc this property implementation must
            return myfolder/myitem.doc. To calculate the entire item URL the engine will
            call <see cref="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ApplicationPath"/> property and attach it to url returned by
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItemAsync.Path"/> property.
            </para>
            <para>
            Every part of the path (between '/' characters) shall be encoded,
            for example using <see cref="T:ITHit.WebDAV.Server.EncodeUtil"/>.
            </para>
            <para>Examples:
            <list type="bullet">
            <item><description>File: myfolder/my%20doc.docx</description></item>
            <item><description>Folder: myfolder/folder/</description></item>
            <item><description>History item: myfolder/mydoc.docx?history</description></item>
            <item><description>Version: myfolder/mydoc.docx?version=5</description></item>
            </list>
            </para>
            </remarks>
            <value><c>String</c> representing relative item path in the repository.</value>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual string Path
{
    get { return path; }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetOwnerAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/> privilege), clients might display the resource owner in their
            user interface.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public void SetOwner(IPrincipal principal)
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetOwnerAsync">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/> privilege), clients might display the resource owner in their user
            interface.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>Can be null.</remarks>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IPrincipal GetOwner()
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetGroupAsync(ITHit.WebDAV.Server.Acl.IPrincipalAsync)">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public void SetGroup(IPrincipal principal)
{
    throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetGroupAsync">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            Can return null if group is not assigned.
            </remarks>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IPrincipal GetGroup()
{
    return null;
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetSupportedPrivilegeSetAsync">
            <summary>
            Retrieves the privileges defined for the resource.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<SupportedPrivilege> GetSupportedPrivilegeSet()
{
    RequireReadPrivilege();
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetCurrentUserPrivilegeSetAsync">
            <summary>
            Retrieves the exact set of privileges (as computed by
            the server) granted to the currently authenticated HTTP user. Aggregate privileges and their contained
            privileges are listed. A user-agent can use the value of this property to adjust its user interface to
            make actions inaccessible (e.g., by graying out a menu item or button) for which the current principal
            does not have permission. This property is also useful for determining what operations the current
            principal can perform, without having to actually execute an operation.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<Privilege> GetCurrentUserPrivilegeSet()
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Specifies the list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <param name="propertyNames">List of properties that might be retrieved from those <see cref="!:IPrincipal"/>
            returned.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            <paramref name="propertyNames"/>Is for optimization purposes and you may ignore it.
            For "principal-pop-set" report engine will call this method, retrieve all principals from result
            and extract properties specified in <paramref name="propertyNames"/> from it. In this case prefetching
            these properties may improve performance.
            </remarks>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<ReadAce> GetAcl(IList<PropertyName> propertyNames)
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.SetAclAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})">
            <summary>
            Sets list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <remarks>
            Two common operations are to add or remove an ACE from an existing access
            control list. To accomplish this, a client uses the PROPFIND method to retrieve the value of the DAV:acl
            property, then parses the returned access control list to remove all inherited and protected ACEs (these
            ACEs are tagged with the DAV:inherited and DAV:protected XML elements). In the remaining set of
            non-inherited, non-protected ACEs, the client can add or remove one or more ACEs before submitting the
            final ACE set in the request body of the ACL method.
            It is possible that the ACEs visible to the current user in the DAV:acl property may only be a portion of
            the complete set of ACEs on that resource. If this is the case, an ACL request only modifies the set of
            ACEs visible to the current user, and does not affect any non-visible ACE.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            It is possible for status code to be <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> and error description one of values
            in <see cref="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails"/> class.
            </exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public void SetAcl(IList<WriteAce> aces)
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetAclRestrictionsAsync">
            <summary>
            Defines the types of ACLs supported by this server, to avoid clients needlessly getting
            errors. When a client tries to set an ACL via the ACL method, the server may reject the attempt to set
            the ACL as specified.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public AclRestriction GetAclRestrictions()
{
    return new AclRestriction { NoInvert = true };
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetInheritedAclSetAsync">
            <summary>
            Contains a set of items that also control the access to this item.
            To have a privilege on an item, not only must the ACL on that item (specified in the <see cref="N:ITHit.WebDAV.Server.Acl"/>
            property of that item) grant the privilege, but so must the ACL of each items identified in the
            <see cref="!:GetInheritedAclSet"/> property of that item. Effectively, the privileges granted by the current
            ACL are ANDed with the privileges granted by each inherited ACL.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<IHierarchyItem> GetInheritedAclSet()
{
    var current = this;
    var parent = current.GetParent();
    while (parent != null)
    {
        var accessControl = File.GetAccessControl(parent.fileSystemInfo.FullName);
        var acl = accessControl.GetAccessRules(true, false, typeof(SecurityIdentifier));
        if (acl.Count > 0)
        {
            yield return parent;
        }

        current = parent;
        parent = current.GetParent();
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetPrincipalCollectionSetAsync">
            <summary>
            Retrieves a set of root collections that contain the
            principals that are available on the server that implements this resource. It can be used to retrieve the 
            <see cref="!:IHierarchyItem.Name"/> properties
            of all principals on that server, thereby yielding human-readable
            names for each principal that could be displayed in a user interface.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<IPrincipalFolder> GetPrincipalCollectionSet()
{
    return new IPrincipalFolder[]
               {
                   new UserFolder(context),
               };
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.ResolveWellKnownPrincipalAsync(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Returns predefined principal.
            </summary>
            <param name="wellKnownPrincipal">One of <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal"/> values.</param>
            <returns>Well known principal or <c>null</c> if it is not supported.</returns>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IPrincipal ResolveWellKnownPrincipal(WellKnownPrincipal wellKnownPrincipal)
{
    throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetItemsByPropertyAsync(ITHit.WebDAV.Server.Acl.MatchBy,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Find all resources in the subtree which have either Group or Owner (defined by <paramref name="matchBy"/>
            parameter) which identifies current user or group current user belongs to.
            For example, this report can return all of the resources in a collection
            hierarchy that are owned by the current user.
            </summary>
            <param name="matchBy">Identifies whether to search by owner or group.</param>
            <param name="props">Properties requested for found items.</param>
            <returns>Matching resources.</returns>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public virtual IEnumerable<IAclHierarchyItem> GetItemsByProperty(MatchBy matchBy, IList<PropertyName> props)
{
    yield break;
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItemAsync.GetCurrentUserPrincipalAsync">
            <summary>
            Retrieves currently logged in principal.
            </summary>
            <returns>Currently logged in principal.</returns>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[public IPrincipal GetCurrentUserPrincipal()
{
    return User.FromName(context.UserName, context);
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipalAsync">
            <summary>
            A principal is an item that represents a distinct human or computational actor that initiates access to
            items in WebDAV repository. 
            </summary>
            <remarks>
            Users and groups are represented as principals in many implementations;
            other types of principals are also possible. 
            A principal item may be a group, where a group is a principal that represents a set of other principals,
            called the members of the group. If a person or computational agent matches a principal resource that is a
            member of a group, they also match the group. Membership in a group is recursive, so if a principal is a
            member of group GRPA, and GRPA is a member of group GRPB, then the principal is also a member of
            GRPB.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.SetGroupMembersAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.IPrincipalAsync})">
            <summary>
            Replaces members of the group to be those specified in <paramref name="members"/> parameter.
            </summary>
            <param name="members">New member(user or groups) list.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.SetGroupMembers&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembersAsync">
            <summary>
            Retrieves principals that are direct members of this group. 
            </summary>
            <remarks>
            Since a group
            may be a member of another group, a group may also have indirect members (i.e., the members of its direct
            members). 
            </remarks>
            <returns>Members of the group identified by this principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.GetGroupMembers&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.IsWellKnownPrincipal(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Determines whether the principal is well known, the one that is defined by
            <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal"/> enumeration.
            </summary>
            <param name="wellknownPrincipal">Type of wellknown principal to check this one against.</param>
            <returns>Whether the principal is <paramref name="wellknownPrincipal"/>.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.IsWellKnownPrincipal&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalAsync.GetGroupMembershipAsync">
            <summary>
            Identifies the groups in which the principal is directly a member. 
            </summary>
            <remarks>
            Note that a server may
            allow a group to be a member of another group, in which case the <see cref="!:GetGroupMembership"/>
            of those other groups would need to be queried in order to determine the groups in which the principal
            is indirectly a member.
            </remarks>
            <returns>Returns group this principal belongs to.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.GetGroupMembership&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync">
            <summary>
            Shall be implemented by items which serve as folders for principals.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.IItemCollectionAsync">
            <summary>
            Base interface for folders.
            </summary>
            <remarks>
            <para>Base interface for all kinds of folders (<see cref="!:IFolder"/>, <see cref="!:IPrincipalFolder"/> etc.).</para>
            <para>In addition to methods and properties provided by <see cref="!:IHierarchyItem"/> interface this interface also provides <see cref="!:IItemCollection.GetChildren"/> method to list children of this folder.</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IItemCollectionAsync.GetChildrenAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets direct children of this folder.
            </summary>
            <param name="propNames">List of properties requested by the client.</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> with <see cref="!:IHierarchyItem"/> items. Each item is a file or folder item.</returns>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual IEnumerable<IHierarchyItem> GetChildren(IList<PropertyName> propNames)
{
    // Enumerates all child files and folders.
    // You can filter children items in this implementation and 
    // return only items that you want to be visible for this 
    // particular user.

    FileSystemInfo[] fileInfos =
        context.FileOperation(
            this,
            () => dirInfo.GetFileSystemInfos(),
            Privilege.Read);

    foreach (FileSystemInfo fileInfo in fileInfos)
    {
        string childPath = Path + EncodeUtil.EncodeUrlPart(fileInfo.Name);
        IHierarchyItem child = context.GetHierarchyItem(childPath);
        if (child != null)
        {
            yield return child;
        }
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.CreateFolderAsync(System.String)">
            <summary>
            Creates principal folder with given name.
            </summary>
            <param name="name">Principal folder name.</param>
            <returns>Newly created folder.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.CreateFolder&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.CreatePrincipalAsync(System.String)">
            <summary>
            Creates principal with given name.
            </summary>
            <param name="name">Principal name</param>
            <returns>Newly created principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            The principal created can be either group or user. One of the way to distinguish is
            to create separate folders for users and for groups, so in one folder only users
            can be created, and in another one only groups.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.CreatePrincipal&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.FindPrincipalsByPropertyValuesAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Performs a search for all principals in this folder whose properties contain
            character data that matches the search criteria specified.
            One expected use of this method is to
            discover principals by searching for them by name. This is
            done by searching over <see cref="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME"/> (<see cref="!:IHierarchyItem.Name"/>),
            which is defined on all principals.
            </summary>
            <param name="propValuesToSearch">Properties with values to search for.</param>
            <param name="propsToReturn">Properties to return for each item found.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            If there are too many items server may return this exception with status
            <see cref="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED"/> and description 
            <see cref="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS"/>
            </exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.FindPrincipalsByPropertyValues&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.GetPrincipalSearcheablePropertiesAsync">
            <summary>
            Identifies those properties that may be searched using the
            <see cref="!:FindPrincipalsByPropertyValues"/> method (DAV:principal-property-search REPORT defined
            in Section 9.4).
            A client could use the results of this method
            to present a query interface to the user for retrieving principals.
            </summary>
            <returns>Searcheable properties.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.GetPrincipalSearcheableProperties&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolderAsync.GetMatchingPrincipalsAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Is used to find all groups residing in the subtree of current item which contain currently authenticated
            user. The user itself shall also be included if it is located in the subtree of this item.
            </summary>
            <param name="props">Properties to return with every item found.</param>
            <returns>Groups which contain currently authenticated user.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.GetMatchingPrincipals&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal">
            <summary>
            Lists predefined principals having special meaning in WebDav.
            Urls of these principals will be retrieved using <see cref="!:IAclHierarchyItem.ResolveWellKnownPrincipal"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All">
            <summary>
            Matches all principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated">
            <summary>
            Matches all authenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated">
            <summary>
            Matches all unauthenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Self">
            <summary>
            Matches currently logged in principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Owner">
            <summary>
            Matches principal that is owner of hierarchy item.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Group">
            <summary>
            Matches principal that is group of hierarchy item.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.Privilege">
            <summary>
            Specifies a privilege that can be given to a principal on an item.
            </summary>
            <remarks>
            Ability to perform a method on an item is controlled by one or more privileges.
            A principal with no privileges to a resource will be denied any access to that resource, unless the principal
            matches an ACE constructed using the <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated"/>, or <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated"/>
            pseudo-principals.
            Privileges may be containers of other privileges, in which case they are termed "aggregate privileges". If a
            principal is granted or denied an aggregate privilege, it is semantically equivalent to granting or denying each
            of the aggregated privileges individually. For example, an implementation may define add-member and
            remove-member privileges that control the ability to add and remove a member of a group. Since these
            privileges control the ability to update the state of a group, these privileges would be aggregated by the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege on a group, and granting the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege
            on a group would also grant the add-member and remove-member privileges.
            Privileges may be declared to be "abstract" for a given resource, in which case they cannot be set in an ACE on
            that resource. Aggregate and non-aggregate privileges are both capable of being abstract. Abstract privileges
            are useful for modeling privileges that otherwise would not be exposed via the protocol. Abstract privileges
            also provide server implementations with flexibility in implementing the privileges.  For example, if a server
            is incapable of separating the read item capability from the read ACL  capability, it can still model the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> privileges defined in this specification by
            declaring them abstract, and containing them within a non-abstract aggregate privilege (say, read-all) that
            holds <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>. In this way, it is possible to set
            the aggregate privilege, read-all, thus coupling the setting of <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, but it is not possible to set <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, or
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> individually. Since aggregate privileges can be abstract, it is also possible
            to use abstract privileges to group or organize non-abstract privileges. Privilege containment loops are not
            allowed; therefore, a privilege MUST NOT contain itself. For example, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> cannot
            contain <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>. The set of privileges that apply to a particular item may vary with the 
            type of item (folder, resource), as well as between different server implementations. To promote 
            interoperability, however, a set of well-known privileges (e.g., <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.All"/>) is defined, which can at least
            be used to classify the other privileges defined on a particular resource. 
            Server implementations MAY define new privileges beyond those defined in <see cref="T:ITHit.WebDAV.Server.Acl.Privilege"/>. Privileges
            defined by individual implementations MUST NOT use the DAV: namespace, and instead should use a
            namespace that they control, such as an http scheme URL.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Namespace">
            <summary>
            Namespace of privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Name">
            <summary>
            Privilege name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Read">
            <summary>
            Controls methods that return information about the state of the resource, including the
            resource's properties. Affected methods include downloading content and retrieving information about item.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to donwloading content and retrieving
            information must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> - if an ACL grants
            access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, the client may expect that no other privilege needs to be granted to have
            access to downloading content and retrieving information.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Write">
            <summary>
            Controls methods that lock an item or modify the content, properties, or 
            membership of a collection.
            </summary>
            <remarks>
            State modification is  also controlled via locking, so effective write access requires that both write
            privileges and write locking requirements are satisfied. Any implementation-defined privilege that also
            controls access to methods modifying content, properties or folder membership must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, the client may expect that no
            other privilege needs to be granted to modify item's state.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties">
            <summary>
            Controls methods that modify properties of the resource.
            Such as <see cref="!:IHierarchyItem.UpdateProperties"/>.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to methods modifying
            properties must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/> - e.g., if an ACL grants access to
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/>, the client can safely expect that no other privilege needs to be granted
            to have access to modifying properties.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent">
            <summary>
            Controls methods that modify the content of an existing resource, such as <see cref="!:IContent.Write"/>.
             </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to content must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/> - e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/>,
            the client can safely expect that no other privilege needs to be granted to have access to modifying content.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock">
            <summary>
            Controls the use of the <see cref="!:ILock.Unlock"/> method by a principal other than the lock owner
            (the principal that created a lock can always perform an <see cref="!:ILock.Unlock"/>).
            </summary>
            <remarks>
            While the set of users who may lock a
            resource is most commonly the same set of users who may modify a resource, servers may allow various kinds
            of administrators to unlock resources locked by others. Any privilege controlling access by non-lock owners
            to <see cref="!:ILock.Unlock"/> must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/>.
            A lock owner can always remove a lock by issuing an <see cref="!:ILock.Unlock"/> with the correct lock token
            and authentication credentials. That is, even if a principal does not have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege,
            they can still remove locks they own. Principals other than the lock owner can remove a lock only if they
            have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege and they issue an <see cref="!:ILock.Unlock"/> with the correct lock
            token. Lock timeout is not affected by the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl">
            <summary>
            Controls the use of <see cref="!:IAclHierarchyItem.GetAcl"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet">
            <summary>
            Controls the use of <see cref="!:IAclHierarchyItem.GetCurrentUserPrivilegeSet"/>.
            </summary>
            <remarks>
            Clients are intended to use this property to visually indicate in their UI items that are dependent on the
            permissions of a resource, for example, by graying out resources that are not writable.
            This privilege is separate from <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> because there is a need to allow most users access
            to the privileges permitted the current user (due to its use in creating the UI), while the full ACL
            contains information that may not be appropriate for the current authenticated user. As a result, the
            set of users who can view the full ACL is expected to be much smaller than those who can read the current
            user privilege set, and hence distinct
            privileges are needed for each.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl">
            <summary>
            Controls user of <see cref="!:IAclHierarchyItem.SetAcl"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Bind">
            <summary>
            Allows creating child items in a collection.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unbind">
            <summary>
            Allows removing child items from collection (for example using <see cref="!:IHierarchyItem.Delete"/>
            or <see cref="!:IHierarchyItem.MoveTo"/>).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.All">
            <summary>
            Is an aggregate privilege that contains the entire set of privileges that can be applied to the item.
            </summary>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the Privilege class.
            </summary>
            <param name="namespace">Privilege namespace.</param>
            <param name="name">Privilege name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Equality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Inequality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.ToString">
            <summary>
            Returns string representation of a privilege.
            </summary>
            <returns>String representation of the privilege.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.PropertyDescription">
            <summary>
            Used in result of <see cref="!:IPrincipalFolder.GetPrincipalSearcheableProperties"/>.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Name">
            <summary>
            Property name.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Description">
            <summary>
            Property description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Lang">
            <summary>
            Property description language.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.ReadAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal">
            <summary>
            Principal to which privileges are granted and denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsProtected">
            <summary>
            Indicates that this ACE is protected and an attempt to remove it will fail.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.InheritedFrom">
            <summary>
            If not null indicates a resource from which this Ace is inherited.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsInvert">
            <summary>
            If this property is true then this ACE grants/denies privileges to all
            principals NOT matching the one in <see cref="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal"/> property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails">
            <summary>
            Error codes that can be returned as part of <see cref="T:ITHit.WebDAV.Server.DavException"/> during call
            to <see cref="!:IAclHierarchyItem.SetAcl"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with each other. This is
            a catchall error code indicating that an implementation-specific ACL restriction has been violated.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoProtectedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            protected ACEs on the resource. For example, if the resource has a protected ACE granting DAV:write to a
            given principal, then it would not be consistent if the ACL request submitted an ACE denying DAV:write to
            the same principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInheritedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            inherited ACEs on the resource. For example, if the resource inherits an ACE from its parent collection
            granting DAV:write to a given principal, then it would not be consistent if the ACL request submitted an ACE
            denying DAV:write to the same principal. Note that reporting of this error will be implementation-dependent.
            Implementations MUST either report this error or allow the ACE to be set, and then let normal ACE evaluation
            rules determine whether the new ACE has any impact on the privileges available to a specific principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.LimitedNumberOfAces">
            <summary>
            (DAV:limited-number-of-aces): The number of ACEs submitted in the ACL request MUST NOT exceed the
            number of ACEs allowed on that resource. However, ACL-compliant servers MUST support at least one ACE
            granting privileges to a single principal, and one ACE granting privileges to a group.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.DenyBeforeGrant">
            <summary>
            All non-inherited deny ACEs MUST precede all non-inherited grant ACEs.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.GrantOnly">
            <summary>
            The ACEs submitted in the ACL request MUST NOT include a deny ACE. This
            precondition applies only when the ACL restrictions of the resource include the DAV:grant-only constraint
            (defined in Section 5.6.1).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInvert">
            <summary>
            The ACL request MUST NOT include a DAV:invert element. This precondition applies only
            when the ACL semantics of the resource includes the DAV:no-invert constraint (defined in Section 5.6.2).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAbstract">
            <summary>
            The ACL request MUST NOT attempt to grant or deny an abstract privilege (see
            Section 5.3).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NotSupporterPrivilege">
            <summary>
            The ACEs submitted in the ACL request MUST be supported by the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.MissingRequiredPrincipal">
            <summary>
            The result of the ACL request MUST have at least one ACE for each
            principal identified in a DAV:required-principal XML element in the ACL semantics of that resource (see
            Section 5.5).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.RecognizedPrincipal">
            <summary>
            Every principal URL in the ACL request MUST identify a principal resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.AllowedPrincipal">
            <summary>
            The principals specified in the ACEs submitted in the ACL request MUST be
            allowed as principals for the resource. For example, a server where only authenticated principals can access
            resources would not allow the DAV:all or DAV:unauthenticated principals to be used in an ACE, since these
            would allow unauthenticated access to resources.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SupportedPrivilege">
            <summary>
            Identifies the privileges defined for the resource.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.SupportedPrivilege.#ctor">
            <summary>
            Initializes a new instance of the SupportedPrivilege class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Privilege">
            <summary>
            Privilege that this object describes.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.IsAbstract">
            <summary>
            An abstract privilege MUST NOT be used in an ACE for that resource. Servers MUST fail an attempt to set an
            abstract privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Description">
            <summary>
            A description is a human-readable description of what this privilege controls access to.
            </summary>        
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.DescriptionLanguage">
            <summary>
            Language of description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.AggregatedPrivileges">
            <summary>
            Aggregate privileges list all of the privileges this privilege aggregates.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WriteAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.Principal">
            <summary>
            Principal to which privileges are granted/denied.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by the calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBeShared">
            <summary>
            Indicates that the calendar collection can be shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBePublished">
            <summary>
            Indicates that the calendar collection can be published.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleShare">
            <summary>
            Describes sharing operation specific to Apple iCal.
            </summary>
            <remarks>The list of items of this type is passed to <see cref="!:IAppleCalendar.UpdateSharing"/> metod.</remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Operation">
            <summary>
            Describes sharing operation applied to calendar item.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleSharingOperation">
            <summary>
            Describes sharing operations that are specific to Apple iCal
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Read">
            <summary>
            Grant read privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.ReadWrite">
            <summary>
            Grant read and write privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Withdraw">
            <summary>
            Withdraw access to the calendar.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarComponentType">
            <summary>
            Specifies the calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.
            </summary>
            <remarks>
            For more details see: http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VEVENT">
            <summary>
            Event calendar component.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VTODO">
            <summary>
            To-do calendar component.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarSharedBy">
            <summary>
            Indicates that the calendar is shared and if it is shared by the current user who is the owner of the calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.NotShared">
            <summary>
            Indicates that the calendar is not shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner">
            <summary>
            Indicates that the calendar is owned by the current user and is being shared by them.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared">
            <summary>
            Indicates that the calendar is owned by another user and is being shared to the current user.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync">
            <summary>
            Assists in finding calendars on a CalDAV server.
            </summary>
            <remarks>
            <para>
            This interface helps finding folders that contain calendars. You will implement this interface on server 
            root as well as on any other folders that you wish to report a list of folders that contain calendars.
            </para>
            <para>
            Items that implement this interface return list of folders that contain calendars owned by the principal. 
            To find folders with calendars the Engine calls <see cref="!:ICalendarDiscovery.GetCalendarHomeSet"/> method.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarItem">
            <summary>
            Represents folder, file of principal on a CalDAV server.
            </summary>
            <remarks>
            <para>This is the marker interface, it does not provide any methods or properties.</para>
            <para>
            Items that implement this interface report CalDAV support in OPTIONS requests. 
            If this intervace is found on an item, the DAV header will include <b>calendar-access</b> token.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync.GetCalendarHomeSetAsync">
            <summary>
            Returns list of folder items that contain calendars owned by this principal.
            </summary>
            <remarks>
            <para>
            Note that this property returns list of folders that contain calendar folders, NOT the calendar folders themselves.
            </para>
            <para>
            http://tools.ietf.org/html/rfc4791#section-6.2.1
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarDiscoveryAsync.CalendarHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>calendar-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <para>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>calendar-home-set</b> feature for specific client. 
            </para>
            <para>
            iOS and OS X does require <b>calendar-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CalDAV client. iOS starts immediate synchronization of all calendars found on the server 
            via home-set request. Typically you will always enable home-set for iOS and OS X CalDAV clients, but may disable it for other clients.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarMultigetFolderAsync">
            <summary>
            Represents calendar folder that can process <b>addressbook-multiget</b> request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarMultigetFolderAsync.MultiGetAsync(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of calendar files requested by the client.
            </summary>
            <remarks>
            <para>
            This method is called by the Engine during <b>calendar-multiget</b> call.
            </para>
            <para>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or null if the item is not found.
            </para>
            </remarks>
            <param name="pathList">Calendar files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files. Returns null for any item that is not found.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteAccess">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.Read">
            <summary>
            Indicates that the access level granted only allows sharees to read data in the shared calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.ReadWrite">
            <summary>
            Indicates that the access level granted allows sharees to read and write all data in the shared calendar, with the exception of components that would trigger scheduling.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync">
            <summary>
            Calendars that imlement this interface support calendar 
            sharing from iCal on iOS and Mac OS X.
            </summary>
            <remarks>
            <para>
            Adding this interace on calendar item 
            enables 'Share Calendar' menu option in Calendar on iOS and Mac OS X.
            </para>
            <para>
            Items with this interface will add <b>calendarserver-sharing</b> token to DAV header on OPTIONS requests.
            </para>
            <para>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync">
            <summary>
            Represents a calendar on a CalDAV server.
            </summary>
            <remarks>
            <para>
            Folders that implement this interface can process <b>calendar-multiget</b> 
            report and <b>calendar-query</b> reports. 
            These reports provide information about calendar files in this calendar.
            </para>
            <para>
            A calendar can contain calendar files only (items that implement 
            <see cref="!:ICalendarFile"/>) and folders that are not <see cref="!:ICalendarFolder"/> 
            folders. "Nesting" of calendar folders within other calendar folders at 
            any depth is NOT allowed.
            </para>
            <para>http://tools.ietf.org/html/rfc4791#section-4.2</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFolderAsync">
            <summary>
            Represents a folder in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods that WebDAV server folder objects must implement.
            In addition to methods and properties provided by <see cref="!:IHierarchyItem"/> and <see cref="!:IItemCollection"/> this interface also provides
            methods for creating WebDAV items (folders and files).
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolderAsync.CreateFileAsync(System.String)">
            <summary>
            Creates new WebDAV file with the specified name in this folder.
            </summary>
            <param name="name">Name of the file to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>You must create a file in your repository during this call. After calling this method Engine calls
            <see cref="!:IContent.Write"/>.</remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IFile CreateFile(string name)
{
    RequireHasToken();
    string fileName = System.IO.Path.Combine(fileSystemInfo.FullName, name);
    
    context.FileOperation(
        this,
        () => new FileStream(fileName, FileMode.CreateNew).Dispose(),
        Privilege.Bind);

    return (IFile)context.GetHierarchyItem(Path + EncodeUtil.EncodeUrlPart(name));
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolderAsync.CreateFolderAsync(System.String)">
            <summary>
            Creates new WebDAV folder with the specified name in this folder.
            </summary>
            <param name="name">Name of the folder to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[virtual public void CreateFolder(string name)
{
    RequireHasToken();
    context.FileOperation(
        this,
        () => dirInfo.CreateSubdirectory(name),
        Privilege.Bind);
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.SupportedComponentTypes">
            <summary>
            Gets a calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.        
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.CalendarDescription">
            <summary>
            Gets a human-readable description of the calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxResourceSize">
            <summary>
            Gets a numeric value indicating the maximum size of a
            resource in bytes that the server is willing to accept when a
            calendar object resource is stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.5
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxInstances">
            <summary>
            Gets a numeric value indicating the maximum number of
            recurrence instances that a calendar object resource stored in a
            calendar collection can generate.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.8
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.MaxAttendeesPerInstance">
            <summary>
            Provides a numeric value indicating the maximum number of
            ATTENDEE properties in any instance of a calendar object resource
            stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.9
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.UtcMinDateTime">
            <summary>
            Gets a DATE-TIME value indicating the earliest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.6
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolderAsync.UtcMaxDateTime">
            <summary>
            Gets a DATE-TIME value indicating the latest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.7
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.UpdateSharingAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.CalDav.AppleShare})">
            <summary>
            This metod is called when user is granting or 
            withdrowing acces to the calendar. 
            </summary>
            <remarks>
            <para>
            In this metod implementation you will grant 
            or withdraw acces to the calendar as well as you will send sharing invitation.
            </para>
            <para>
            When user is updating acces rights, for example changing 
            acces rights from read-write to read-only the Apple iCal client application 
            submits 'delete share' and 'add share' with new access rights in a  
            single request. Your implementation must first delete all shares and 
            than add new shares regardless of the order they are sent and listed 
            in <see href="sharesToAddAndRemove"/> parameter.
            </para>
            <para>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</para>
            </remarks>
            <param name="sharesToAddAndRemove">Each item in this list describes the share to 
            add or delete.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.AllowedSharingModes">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by this calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.Invite">
            <summary>
            Provides a list of users to whom the calendar has been shared.
            </summary>
            <remarks>
            <para>
            If calendar is shared, in addition to the list of <see cref="T:ITHit.WebDAV.Server.CalDav.SharingInvite"/> it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </para>
            <para>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.IAppleCalendarAsync.SharedBy">
            <summary>
            Indicates that the calendar is shared and if it is shared by owner.
            </summary>
            <remarks>
            <para>
            If calendar is shared, it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </para>
            <para>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.1)  
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleInboxFolderAsync">
            <summary>
            Represents scheduling inbox folder.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="!:IFolder"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            <b>calendar-auto-schedule</b> support in response to the OPTIONS request in DAV header.
            </para>
            <para>Folders of this type contain copies of incoming scheduling messages.</para>
            <para>Scheduling inbox folder can not contain any other folders.</para>
            <para>More details could be found at http://tools.ietf.org/html/rfc6638#section-2.2</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarPrincipalAsync">
            <summary>
            Represents principal on a server that supports CalDAV.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFileAsync">
            <summary>
            Represents calendar file. 
            </summary>
            <remarks>
            <para>
            Items of this type will return content returned from 
            <see cref="!:IContent.Read"/> method in <b>calendar-data</b> 
            CalDAV property.
            </para>
            <para>
            This is the marker interface, it does not provide any methods or properties in 
            addition to methods and properties provided by <see cref="!:IFile"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces.
            </para>
            <para>
            Calendar file contains definition of the calendar resource in the iCalendar format. 
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFileAsync">
            <summary>
            Represents a file in the WebDAV repository.
            </summary>
            <remarks>
            This interface represents a file in a repository. This is a marker interface derived from <see cref="!:IContent"/> 
            and <see cref="!:IHierarchyItem"/>, it does not add any additional properties or methods.    
            <see cref="!:IContent.ContentType"/> property must return the MIME type of the file.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.IContentAsync">
            <summary>
            Base interface for items that have content, like <see cref="T:ITHit.WebDAV.Server.Class1.IFileAsync"/>.
            </summary>
            TODO: does this need to be a separate interface?
        </member>
        <member name="M:ITHit.WebDAV.Server.IContentAsync.ReadAsync(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Reads the file content from the repository and writes it to the specified stream.
            </summary>
            <param name="output">Output stream.</param>
            <param name="startIndex">The zero-bazed byte offset in file content at which to begin copying bytes to
            the output stream.</param>
            <param name="count">The number of bytes to be written to the output stream.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            By default ASP.NET buffers content on server side before sending output. You must turn off buffering to
            eliminate keeping entire file content in memory before sending:
            <code>
            HttpContext.Current.Response.BufferOutput = false;
            </code>
            </para>
            <para>
            Client application can request only a part of a file specifying <b>Range</b> header. Download managers 
            may use this header to download single file using several threads at a time.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual void Read(Stream output, long startIndex, long count)
{
    //Set timeout to maximum value to be able to download large files.
    HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
    if (ContainsDownloadParam(context.Request.RawUrl))
    {
        AddContentDisposition(context, Name);
    }

    context.FileOperation(
        this,
        () => readInternal(output, startIndex, count),
        Privilege.Read);
}

private void readInternal(Stream output, long startIndex, long count)
{
    var buffer = new byte[bufSize];
    using (var fileStream = fileInfo.Open(FileMode.Open, FileAccess.Read, FileShare.Read))
    {
        fileStream.Seek(startIndex, SeekOrigin.Begin);
        int bytesRead;
        var toRead = (int)Math.Min(count, bufSize);

        try
        {
            while (toRead > 0 && (bytesRead = fileStream.Read(buffer, 0, toRead)) > 0)
            {
                output.Write(buffer, 0, bytesRead);
                count -= bytesRead;
            }
        }
        catch (HttpException)
        {
            // The remote host closed the connection (for example Cancel or Pause pressed).
        }
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IContentAsync.WriteAsync(System.IO.Stream,System.String,System.Int64,System.Int64)">
            <summary>
            Saves the content of the file from the specified stream to the WebDAV repository.
            </summary>
            <param name="content">Stream to read the content of the file from.</param>
            <param name="contentType">Indicates the media type of the file.</param>
            <param name="startIndex">Start offset to which content shall be saved.</param>
            <param name="totalFileSize">Entire length of the file. Is is not less then length of
            <paramref name="content"/> stream.</param>
            <returns>Boolean value indicating whether entire stream was written. This value is used by engine to take
            decision whether autocheckin shall be performed.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The file was locked and client did not provide lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>IIS and ASP.NET does not support files upload larger than 2Gb. If you need to upload files larger
            than 2Gb you must develop HttpListener-based WebDAV server or implement resumable upload interfaces.</para>
            <para>
            If you are creating HttpHandler-based WebDAV server you must specify the file 
            maximum upload size in web.config of your web application. By default maximum 
            upload size is set to 4096 KB (4 MB) by ASP.NET. This limit is used to 
            prevent denial of service attacks caused by users posting large files to the 
            server. To increase the upload limit add &lt;httpRuntime&gt; section to your web application web.config
            file and specify the limit in kilobytes: 
            </para>
            <code>
              <![CDATA[
                <configuration>
                   <system.web>
                      ...
                      <httpRuntime maxRequestLength="2097151" /> //2Gb
                      ...
                   </system.web>
                </configuration>
            ]]>
            </code>
            <para>
            When client uploads file to IIS, ASP.NET first creates the file in a the temporary upload directory.
            Only when the entire file is uploaded to server you can read its content from stream. By default ASP.NET
            uploads files to <b>%FrameworkInstallLocation%\Temporary ASP.NET Files</b> folder.
            You must make sure you have enough disk space to keep temporary files uploaded to your server.
            To change this folder location add the following section to your web.config file:
            <code>
              <![CDATA[
               <configuration>
                   <system.web>
                      ...
                      <compilation tempDirectory="temporary files directory" />
                      ...
                   </system.web>
               </configuration>
              ]]>
            </code>
            To avoid temporary file creation and pass content directly to engine set the
            <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/>
            module in your web.config file. Unlike IIS/ASP.NET, HttpListener-based server does not create any
            temporary files when handling uploads.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual bool Write(Stream content, string contentType, long startIndex, long totalFileSize)
{
    RequireHasToken();
    //Set timeout to maximum value to be able to upload large files.
    HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
    return context.FileOperation(
        this,
        () => writeInternal(content, startIndex, totalFileSize),
        Privilege.Write);
}
        
private bool writeInternal(Stream content, long startIndex, long totalLength)
{
    if (startIndex == 0 && fileInfo.Length > 0)
    {
        SafeNativeMethods.TruncateFile(fileInfo);
    }
    RewriteStream("SerialNumber", GetStreamAndDeserialize<int>("SerialNumber", context.Logger) + 1);

    using (var fileStream = fileInfo.Open(FileMode.OpenOrCreate, FileAccess.Write, FileShare.Read))
    {
        if (fileStream.Length < startIndex)
        {
            throw new DavException("Previous piece of file was not uploaded.", DavStatus.PRECONDITION_FAILED);
        }

        fileStream.Seek(startIndex, SeekOrigin.Begin);
        var buffer = new byte[bufSize];

        int lastBytesRead;
        try
        {
            while ((lastBytesRead = content.Read(buffer, 0, bufSize)) > 0)
            {
                fileStream.Write(buffer, 0, lastBytesRead);
                fileStream.Flush();
            }
        }
        catch (HttpException)
        {
            // The remote host closed the connection (for example Cancel or Pause pressed).
        }
    }

    return true;
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContentAsync.ContentType">
            <summary>
            Gets the media type of the file.
            </summary>
            <remarks>
            <para>
            The mime-type provided by this property is returned in a Content-Type header with GET request.
            </para>
            <para>
            When deciding which action to perform when downloading a file some WebDAV clients and browsers 
            (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type
            header returned by server. For identical behavior in all browsers and WebDAV clients your server must
            return a correct mime-type with a requested file.
            </para>
            </remarks>
            <value>The MIME type of the file.</value>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public virtual string ContentType
{
    get { return MimeType.GetMimeType(fileSystemInfo.Extension) ?? "application/octet-stream"; }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContentAsync.ContentLength">
            <summary>
            Gets the size of the file content in bytes.
            </summary>
            <value>Length of the file content in bytes.</value>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public long ContentLength
{
    get { return fileInfo.Length; }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContentAsync.Etag">
            <summary>
            Gets entity tag - string that identifies current state of resource's content.
            </summary>
            <remarks>
            More information about etags is available here: http://en.wikipedia.org/wiki/HTTP_ETag
            You can return here either cheksum or hash or counter which increases with every
            modification.
            This property shall return different value if content changes.
            Return <c>null</c> to indicate that server doesn't support etags.
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public string Etag
{
    get
    {
        var serialNumber = GetStreamAndDeserialize<int>("SerialNumber", context.Logger);
        return string.Format("{0}-{1}", Modified.ToBinary(), serialNumber);
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleOutboxFolderAsync">
            <summary>
            Represents scheduling outbox folder.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="!:IFolder"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            "calendar-auto-schedule" support in response to the OPTIONS request.
            </para>
            <para>
            This type of folders are used as the target for busy time information requests, and to 
            manage privileges that apply to outgoing scheduling requests.
            </para>
            <para>
            Scheduling outbox folder can not contain any other folders. Folders of this type 
            should not be nested under  and <see cref="!:ICalendarFolder"/> items at any depth.
            </para>
            <para>More details culd be found at http://tools.ietf.org/html/rfc6638#section-2.1</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInvite">
            <summary>
            Represents information about invitation.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Status">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Access">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteStatus">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Noresponse">
            <summary>
            Indicates that the sharee has never replied to the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Accepted">
            <summary>
            Indicates that the sharee has accepted the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Declined">
            <summary>
            Indicates that the sharee has declined the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Invalid">
            <summary>
            Indicates that the corresponding sharee is not a valid calendar user known to the server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync">
            <summary>
            Assists in finding addressbooks on a CardDAV server.
            </summary>
            <remarks>
            <para>
            This interface helps finding folders that contain addressbooks. You will implement this interface on server 
            root as well as on any other folders that you wish to report a list of folders that contain address books.
            </para>
            <para>
            Items that implement this interface:
            <list type="number">
            <item><description>Report CardDAV support in OPTIONS requests. The DAV header will include <b>addressbook</b> token.</description></item>
            <item><description>
            Return list of folders that contain addressbooks owned by the principal. 
            To find folders with addressbooks the Engine calls <see cref="!:IAddressbookDiscovery.GetAddressbookHomeSet"/> method.
            </description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem">
            <summary>
            Represents folder, file of principal on a CardDAV server.
            </summary>
            <remarks>
            <para>This is the marker interface, it does not provide any methods or properties.</para>
            <para>
            Items that implement this interface report CardDAV support in OPTIONS requests. 
            If this intervace is found on an item, the DAV header will include <b>addressbook</b> token.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync.GetAddressbookHomeSetAsync">
            <summary>
            Returns list of folder items that contain addressbooks owned by this principal.
            </summary>
            <remarks>
            <para>
            Note that this property returns list of folders that contain addressbook folders, not the addressbook folders themselves.
            </para>
            <para>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookDiscoveryAsync.AddressbookHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>addressbook-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <para>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>addressbook-home-set</b> feature for specific client. 
            </para>
            <para>
            iOS and OS X does require <b>addressbook-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CardDAV client. iOS starts immediate synchronization of all addressbooks found on the server 
            via home-set request. Typically you will always enable heome-set for iOS and OS X CardDAV clients, but may disable it for other clients.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEnvironment">
            <summary>
            Exposes environment specific information like the .net runtime running.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavEnvironment._isRnningOnMono">
            <summary>
            Indicating whether the current .net runtime is mono or not.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEnvironment.#cctor">
            <summary>
            Initializes the <see cref="T:ITHit.WebDAV.Server.DavEnvironment"/> class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEnvironment.IsRunningOnMono">
            <summary>
            Gets a value indicating whether the current .net runtime is mono or not.
            </summary>
            <returns><code>True</code> if the current runtime is mono otherwise <code>false</code>.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavContextBase">
             <summary>
             Serves as the abstract base class for WebDAV context.
             </summary>
             <remarks>
             <para>
             Context holds request, response and provides item factory method <see cref="!:GetHierarchyItem"/>.
             </para>
             <para>
             When you inherit from the <c>DavContext</c> class, you must override <see cref="!:GetHierarchyItem"/> method.
             In this method you will search for file, folder, version or history item in your storage by path provided
             and return it to WebDAV engine.
             </para>
             <para>
             In each HTTP request you will create separate instance of your class derived 
             from <c>DavContext</c> with one of its overloaded constructors and pass it to <see cref="!:DavEngine.Run"/>.
             </para>
             <para>
             The <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> provides several overloaded constructors.
             They are optimized for use with OWIN, with IIS/ASP.NET-based server and in HttpListener-based server.
             You can also implement your own request and response classes to run the Engine in virtually any hosting environment.
             </para>
             </remarks>
             <threadsafety>Instance members of this class are not thread safe.
              You must create a separate instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class for each request.
             </threadsafety>
             <example>
             <para>HttpListener-based server:</para>
             <code>
             class Program
             {
                 static void Main(string[] args)
                 {
                     HttpListener listener = new HttpListener();
                     listener.Prefixes.Add("http://localhost:8080/");
                     listener.Start();
                     DavEngine engine = new DavEngine();
             
                     while (true)
                     {
                         HttpListenerContext context = listener.GetContext();
                         MacOsXPreprocessor.Process(context.Request); // fixes headers for Mac OS X v10.5.3 or later
            
                         if (!userAutorized(context))
                         {
                             context.Response.StatusCode = 401;
                             showLoginDialog(context, context.Response);
                             closeResponse(context);
                             continue;
                         }
            
                         context.Response.SendChunked = false;
            
                         var davContext = new MyDavContext(context, listener.Prefixes);
                         engine.Run(ntfsDavContext);
            
                         if (context.Response.StatusCode == 401)
                         {
                            showLoginDialog(context, context.Response);
                         }
            
                         closeResponse(context);
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(Microsoft.Owin.IOwinContext)">
            <summary>
            Initializes a new instance of the WebDAV context based on OWIN context.
            </summary>
            <remarks>
            <para>
            You must create a new context instance in each request to your WebDAV server passing OWIN context.
            </para>
            </remarks>
            <param name="context"><see cref="T:Microsoft.Owin.IOwinContext"/> instance.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(ITHit.WebDAV.Server.Extensibility.DavRequest,ITHit.WebDAV.Server.Extensibility.DavResponse)">
            <summary>
            Initializes a new instance of the WebDAV context.
            </summary>
            <param name="request"><see cref="T:ITHit.WebDAV.Server.Extensibility.DavRequest"/> implementation.</param>
            <param name="response"><see cref="T:ITHit.WebDAV.Server.Extensibility.DavResponse"/> implementation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Web.HttpContext)">
            <summary>
            Initializes context for IIS/ASP.NET based server.
            </summary>
            <param name="context">An ASP.NET <c>HttpContext</c> object.</param>
            <remarks>
            <para>
            You must create a new context in each request to your WebDAV server passing ASP.NET context.
            </para>
            <para>
            This method instance is optimized for processing requests in IIS/ASP.NET-based server.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public bool IsReusable
    {
        get { return true; }
    }

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngine engine = getOrInitializeEngine(context);

        context.Response.BufferOutput = false;
        DavContext ntfsDavContext = new DavContext(context);
        await engine.Run(ntfsDavContext);
    }

    private DavEngine initializeEngine(HttpContext context)
    {

        var engine = new DavEngine
        {
            Logger = Logger.Instance
            //Use idented responses if debug logging is enabled.
            ,OutputXmlFormatting = debugLoggingEnabled ? Formatting.Indented : Formatting.None
        };
        engine.License = File.ReadAllText(context.Request.PhysicalApplicationPath + "License.lic");

        return engine;
    }

    private DavEngine getOrInitializeEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeEngine(context);
        }

        return (DavEngine)context.Application[ENGINE_KEY];
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Net.HttpListenerContext,System.Net.HttpListenerPrefixCollection)">
            <summary>
            Initializes context for HttpListener-based server.
            </summary>
            <param name="context">An HttpListenerContext object.</param>
            <param name="prefixes">List of HttpListener prefixes.</param>
            <remarks>
            <para>
            You must create new context in each request to your WebDAV server passing
            listener context and list of HttpListener prefixes.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;Listener.DavContextBase&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse">
            <summary>
            This method is called right before engine starts writing response.
            </summary>
            <remarks>
            <para>
            Specifically this method is called when the request is parsed, engine has
            called all methods which shall change state of an item and is ready to
            start writing response.
            </para>
            <para>
            However methods of interfaces which read data may also be called after this method.
            </para>
            <para>
            This method can be overriden to either commit or rollback transaction.
            </para>
            <para>
            In your implementation of <see cref="!:IMethodHandler"/> you need to call 
            <see cref="M:ITHit.WebDAV.Server.DavContextBase.EnsureBeforeResponseWasCalled"/>
            instead of this method to avoid double execution.
            </para>
            </remarks>
            <!-- Failed to insert some or all of included XML --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;DavContextBase.BeforeResponse&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.EnsureBeforeResponseWasCalled">
            <summary>
            Calls <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> only first time this method is invoked.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.LocalizeSatus(ITHit.WebDAV.Server.DavStatus)">
            <summary>
            May be overriden to localize HTTP status message.
            </summary>
            <param name="status">Status to be localized.</param>
            <returns>Localized status which will be written to the response.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItemAsync(System.String)">
            <summary>
            Implementation of this abstract method is used by WebDAV engine to find hierarchy item objects by path.
            </summary>
            <param name="path">
            Path of the hierarchy item object.
            It is always the full path from the root of the WebDAV repository.
            </param>
            <returns>
            Hierarchy item object referenced by the specified path or <c>null</c>
            if hierarchy item not found.
            </returns>
            <remarks>
            <para>
            When you inherit from the <c>DavContext</c> class, you must override this abstract method.
            For WebDAV Class 1 and Class 2 server in this method implementation you will search for file or folder in
            your storage by path provided and return it to WebDAV engine. 
            For DeltaV server in addition to folder or file item you will return version and history items.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public override IHierarchyItem GetHierarchyItem(string path)
{
    path = path.Trim(new[] { ' ', '/' });

    //remove query string.
    int ind = path.IndexOf('?');
    if (ind > -1)
    {
        path = path.Remove(ind);
    }

    IHierarchyItem item = null;

    item = DavFolder.GetFolder(this, path);
    if (item != null)
        return item;

    item = DavFile.GetFile(this, path);
    if (item != null)
        return item;

    logger.LogDebug("Could not find item that corresponds to path: " + path);

    return null; // no hierarchy item that corresponds to path parameter was found in the repository
}

internal string MapPath(string path)
{
    //Convert to local file system path by decoding every part, reversing slashes and appending
    //to repository root.
    string[] encodedParts = path.Split(new[] { "/" }, StringSplitOptions.RemoveEmptyEntries);
    string[] decodedParts = encodedParts.Select<string, string>(EncodeUtil.DecodeUrlPart).ToArray();
    string fileSystemPath = Path.Combine(repositoryPath, string.Join("\\", decodedParts));
    return fileSystemPath;
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Exception">
            <summary>
            Exception which occurred during request execution.
            </summary>
            <remarks>
            <para>
            This can be either exception raised by your implementation or exception
            raised be engine internally. In your <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> implementation you will use it to see 
            if processing was successful or not and to commit or rollback a transaction.
            </para>
            <para>
            This exception will be sent to client.
            </para>
            </remarks>
            <!-- Failed to insert some or all of included XML --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;DavContextBase.BeforeResponse&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Request">
            <summary>
            Object representing current request.
            </summary>
            <remarks>
            This may not be necesserily the request that was passed to the constructor because
            engine may wraps the request and response.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Response">
            <summary>
            Object representing current response.
            </summary>
            <remarks>
            This may not be necesserily the response that was passed to the constructor because
            engine may wrap the request and response.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Engine">
            <summary>
            Instance of DavEngine which is currently executing the request.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.OwinDavRequest">
            <summary>
            Represents HTTP request for OWIN hosted application.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.DavRequest">
            <summary>
            Represents an incoming HTTP request.
            </summary>
            <remarks>
            <para>
            <see cref="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ClientLockTokens"/> property provides access to the lock tokens send by WebDAV client.
            Before modifying locked WebDAV Class 2 server items you must check if client provided necessary lock token.
            </para>
            <para>
            Usually you do not have to implement this class if you host your server in ASP.NET/IIS or in
            HttpListener as there are overloaded constructors of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> optimized for OWIN,
            for ASP.NET/IIS and for HttpListener.
            You can derive your class from this class if you host your server in any other environment
            and pass it to <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> constructor.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.RawUrl">
            <summary>
            Gets information about the URL of the current request.
            </summary>
            <value>
            Url, like /somefolder/?query
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.UrlPrefix">
            <summary>
            Gets concatenated request scheme, host and port, like: http://www.ithit.com:8080
            </summary>
            <value>
            Concatenated scheme, host and port.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ApplicationPath">
            <summary>
            Gets virtual application root path on the server.
            </summary>
            <value>
            The virtual path of the current application.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.HttpMethod">
            <summary>
            Gets the HTTP method specified by the client.
            </summary>
            <value>
            A <c>String</c> that contains the method used in the request.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.Headers">
            <summary>
            Gets a collection of HTTP headers.
            </summary>
            <value>
            A <c>NameValueCollection</c> of headers.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentType">
            <summary>
            Gets the MIME content type of the incoming request. 
            </summary>
            <value>
            A string representing the MIME content type of the incoming request, for example, "text/html". 
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentEncoding">
            <summary>
            Gets the character set of the entity-body.
            </summary>
            <value>
            An <c>Encoding</c> object representing the client's character set.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentLength">
            <summary>
            Specifies the length, in bytes, of content sent by the client.
            </summary>
            <value>
            The length, in bytes, of content sent by the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.InputStream">
            <summary>
            Gets the contents of the incoming HTTP entity body.
            </summary>
            <value>
            A <c>Stream</c> object representing the contents of the incoming HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.UserAgent">
            <summary>
            Gets the User-Agent header.
            </summary>
            <value>
            A <c>string</c> representing User-Agent header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ClientLockTokens">
            <summary>
            Gets a list of lock tokens submitted by client.
            </summary>
            <value>
            <c>StringCollection</c> object containing collection of lock tokens submitted by client.
            </value>
            <remarks>
            <c>ClientLockTokens</c> property provides access to the list of lock tokens 
            submitted by client. These lock tokens were generated during the call to your 
            <see cref="!:ILock.Lock"/> method implementation, associated with the item and returned to client. 
            When WebDAV client is modifying any server item it 
            sends back to server the list of lock tokens. In your WebDAV server Class 2 
            implementation before modifying any locked items you must check if WebDAV 
            client provided necessary lock token.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.#ctor(Microsoft.Owin.IOwinRequest)">
            <summary>
            Creates instance of WebDAV OWIN request.
            </summary>
            <param name="request">OWIN request instance.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.RawUrl">
            <summary>
            Gets information about the URL of the current request.
            </summary>
            <value>
            Url, like /somefolder/?query
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.UrlPrefix">
            <summary>
            Gets concatenated request scheme, host and port, like: http://www.ithit.com:8080
            </summary>
            <value>
            Concatenated scheme, host and port.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.ApplicationPath">
            <summary>
            Gets virtual application root path on the server.
            </summary>
            <value>
            The virtual path of the current application.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.HttpMethod">
            <summary>
            Gets the HTTP method specified by the client.
            </summary>
            <value>
            A <c>String</c> that contains the method used in the request.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.Headers">
            <summary>
            Gets a collection of HTTP headers.
            </summary>
            <value>
            A <c>NameValueCollection</c> of headers.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.ContentType">
            <summary>
            Gets the MIME content type of the incoming request. 
            </summary>
            <value>
            A string representing the MIME content type of the incoming request, for example, "text/html". 
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.ContentEncoding">
            <summary>
            Gets the character set of the entity-body.
            </summary>
            <value>
            An <c>Encoding</c> object representing the client's character set.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.ContentLength">
            <summary>
            Specifies the length, in bytes, of content sent by the client.
            </summary>
            <value>
            The length, in bytes, of content sent by the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.InputStream">
            <summary>
            Gets the contents of the incoming HTTP entity body.
            </summary>
            <value>
            A <c>Stream</c> object representing the contents of the incoming HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavRequest.UserAgent">
            <summary>
            Gets the User-Agent header.
            </summary>
            <value>
            A <c>string</c> representing User-Agent header.
            </value>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.OwinDavResponse">
            <summary>
            Represents HTTP response for OWIN hosted application.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.DavResponse">
            <summary>
            Represents HTTP response.
            </summary>
            <remarks>
            <para>
            Usually you do not have to implement this interfaces if you host your server in ASP.NET/IIS or
            in HttpListener as <see cref="T:ITHit.WebDAV.Server.DavContextBase"></see> provides overloaded constructors optimized
            for OWIN, for ASP.NET/IIS and for HttpListener.
            You can implement this interface if you host your server  in any other environment
            and pass it to <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> constructor.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.DavResponse.AddHeader(System.String,System.String)">
            <summary>
            Adds the specified header and value to the HTTP headers for this response.
            </summary>
            <param name="name">
            The name of the HTTP header to set.
            </param>
            <param name="value">
            The value for the name header.
            </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.DavResponse.Clear">
            <summary>
            Clears all content output from the buffer stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.StatusCode">
            <summary>
            Gets or sets the HTTP status code of the output returned to the client.
            </summary>
            <value>
            An Integer representing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.StatusDescription">
            <summary>
            Sets the HTTP status string of the output returned to the client.
            </summary>
            <value>
            A string describing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentType">
            <summary>
            Sets the HTTP MIME type of the output stream.
            </summary>
            <value>
            The HTTP MIME type of the output stream.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentEncoding">
            <summary>
            Sets the HTTP character set of the output stream.
            </summary>
            <value>
            A <c>Encoding</c> object containing information about the character set of the current response.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentLength">
            <summary>
            Sets the content length of the output stream.
            </summary>
            <value>
            The value of the response's Content-Length header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.OutputStream">
            <summary>
            Enables binary output to the outgoing HTTP content body.
            </summary>
            <value>
            An IO <see cref="T:System.IO.Stream"/> representing the raw contents of the outgoing HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.IsClientConnected">
            <summary>
            Gets a valus indicating whether client is still connected.
            </summary>
            <remarks>
            Most probably this property will be refreshed only when some data fails to send to client.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.#ctor(Microsoft.Owin.IOwinResponse)">
            <summary>
            Creates instance of WebDAV OWIN response.
            </summary>
            <param name="request">OWIN response instance.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.AddHeader(System.String,System.String)">
            <summary>
            Adds the specified header and value to the HTTP headers for this response.
            </summary>
            <param name="name">
            The name of the HTTP header to set.
            </param>
            <param name="value">
            The value for the name header.
            </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.Clear">
            <summary>
            Clears all content output from the buffer stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.StatusCode">
            <summary>
            Gets or sets the HTTP status code of the output returned to the client.
            </summary>
            <value>
            An Integer representing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.StatusDescription">
            <summary>
            Sets the HTTP status string of the output returned to the client.
            </summary>
            <value>
            A string describing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.ContentEncoding">
            <summary>
            Sets the HTTP character set of the output stream.
            </summary>
            <value>
            A <c>Encoding</c> object containing information about the character set of the current response.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.ContentType">
            <summary>
            Sets the HTTP MIME type of the output stream.
            </summary>
            <value>
            The HTTP MIME type of the output stream.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.ContentLength">
            <summary>
            Sets the content length of the output stream.
            </summary>
            <value>
            The value of the response's Content-Length header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.OutputStream">
            <summary>
            Enables binary output to the outgoing HTTP content body.
            </summary>
            <value>
            An IO <see cref="T:System.IO.Stream"/> representing the raw contents of the outgoing HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.OwinDavResponse.IsClientConnected">
            <summary>
            Gets a valus indicating whether client is still connected.
            </summary>
            <remarks>
            Most probably this property will be refreshed only when some data fails to send to client.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.ICardFileAsync">
            <summary>
            Represents business card in addressbook on a CardDAV server.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="!:IFile"/> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem"/> interfaces.  
            Items of this type will return content returned from 
            <see cref="!:IContent.Read"/> method in <b>address-data</b> 
            CardDAV property.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync">
            <summary>
            Represents address book on a CardDAV server.
            </summary>
            <remarks>
            <para>
            Items of this type represent folder that contain business card files.
            </para>
            <para>
            Folders that implement this interface can process <b>addressbook-multiget</b> CardDAV report. 
            This report provides information about business card records in this address book.
            </para>
            <para>
            An address book folder can contain business card files only (items that implement <see cref="!:ICardFile"/>). 
            and folders that are NOT <see cref="!:IAddressbookFolder"/> folders. 
            "Nesting" of address book folders within other address book folders at any depth is NOT allowed.
            </para>
            <para>http://tools.ietf.org/html/rfc6352#section-5.2</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync.MultiGetAsync(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of business card files requested by the client.
            </summary>
            <remarks>
            <para>
            This method is called by the Engine during <b>addressbook-multiget</b> call.
            </para>
            <para>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or null if the item is not found.
            </para>
            </remarks>
            <param name="pathList">Address book files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of business card files. Returns null for any item that is not found.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookFolderAsync.AddressbookDescription">
            <summary>
            Gets a human-readable description of the address book.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookPrincipalAsync">
            <summary>
            Represents principal on a server that supports CardDAV.
            </summary>
            <remarks>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="!:IPrincipal"/> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem"/> interfaces.  
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockLevel">
            <summary>
            Level of lock.
            </summary>
            <remarks>
            If a user sets an exclusive lock, other users will not be able to set any locks. If a user sets shared lock 
            other users will be able to set only shared lock on the item. There could be only 1 exclusive lock set on an 
            item or it can have 1 or more shared locks.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Shared">
            <summary>
            Shared lock.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Exclusive">
            <summary>
            Exclusive lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.RefreshLockResult">
            <summary>
            Result of <see cref="!:ILock.RefreshLock"/> operation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.RefreshLockResult.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.TimeSpan,System.String)">
            <summary>
            Initializes a new instance of the RefreshLockResult class.
            </summary>
            <param name="isDeep">Indicates whether a lock is enforceable on the subtree.</param>
            <param name="level">Determines whether lock is shared.</param>
            <param name="owner">Principal taking out a lock.</param>
            <param name="timeOut">Timeout value. TimeSpan.MaxValue means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Level">
            <summary>
            Determines whether lock is isShared.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.TimeOut">
            <summary>
            Gets/sets timeout.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Owner">
            <summary>
            Gets/sets information about the principal taking out a lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.ToDo">
            <summary>
            The class must be redesigned in accordance with RFC
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.IToDo">
            <summary>
            Implemented properties for VTODO component (except those ones from CalendarComponent class).
            </summary>
            <remarks>
            Order taken from RFC.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ArgumentUtil">
            <summary>
            Utility to check arguments.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgumentNotNull(System.Object,System.String)">
            <summary>
            Checks that argument is not null.
            </summary>
            <param name="obj">Argument to check.</param>
            <param name="paramName">Argument name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgument(System.Boolean,System.String)">
            <summary>
            Checks argument for certain condition.
            </summary>
            <param name="b">Condition result.</param>
            <param name="s">Argument name.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.InvalidLicenseException">
            <summary>
            Exception that indicates that the license is invalid.
            </summary>
            <remarks>The license is invalid.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseValidator">
            <summary>
            Validates license file.
            </summary>
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.SearchDavHandler">
            <summary>
            Summary description for SearchDavHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseDavHandler">
            <summary>
            Summary description for BaseDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync">
            <summary>
            Represents HTTP method handler.
            </summary>
            <remarks>
            <para>
            The IT Hit WebDAV Server Engine allows creating custom HTTP handlers and replacing original engine handlers. 
            To add or replace handler call <see cref="!:DavEngine.RegisterMethodHandler"/> method passing HTTP method
            name and object instance 
            implementing <see cref="!:IMethodHandler"/>. The original handler, if any, 
            is returned from <see cref="!:DavEngine.RegisterMethodHandler"/> method. 
            </para>
            <para>
            The <see cref="!:ProcessRequest"/> method of this interface is called by the engine during 
            <see cref="!:DavEngine.Run"/> call. 
            The hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> is passed to ProcessRequest 
            method as a parameter.
            </para>
            </remarks>
            <remarks>
            The handler must call <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> when all update methods have been called and 
            the handler is about 
            to start writing response.
            </remarks>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[internal class MyCustomGetHandler : IMethodHandler
{
    public IMethodHandler OriginalHandler { get; set; }

    public bool EnableOutputBuffering
    {
        get { return false; }
    }

    public bool EnableOutputDebugLogging
    {
        get { return false; }
    }

    public bool EnableInputDebugLogging
    {
        get { return false; }
    }

    public async Task ProcessRequest(DavContextBase context, IHierarchyItem item)
    {
        if (item is IFolder)
        {
            // In case of GET requests to WebDAV folders we serve a web page to display 
            // any information about this server and how to use it.

            // Remember to call EnsureBeforeResponseWasCalled here if your context implementation
            // makes some useful things in BeforeResponse.
            context.EnsureBeforeResponseWasCalled();
            IHttpAsyncHandler page = (IHttpAsyncHandler)System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(
                "~/MyCustomHandlerPage.aspx", typeof(MyCustomHandlerPage));

            // here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required.
            page.BeginProcessRequest(HttpContext.Current, null, null);
        }
        else
        {
            OriginalHandler.ProcessRequest(context, item);
        }
    }
    
    public bool AppliesTo(IHierarchyItem item)
    {
        return item is IFolder || OriginalHandler.AppliesTo(item);
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync.ProcessRequestAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Enables processing of HTTP Web requests by a custom handler.
            </summary>
            <param name="context">
             Instance of your context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.
            </param>
            <param name="item">Hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> or 
            <b>null</b>.
            </param>
            <remarks>The <see cref="!:ProcessRequest"/> method is called by the engine during <see cref="!:DavEngine.Run"/> 
            call. The hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> is 
            passed to this method.  If <see cref="!:DavContextBase.GetHierarchyItem"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this method shall be enlisted in 'supported-method-set' for 
            <paramref name="item"/>.
            </summary>
            <param name="item">Hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> or 
            <b>null</b>.</param>
            <returns>Boolean indicating whether this handler implementation can handle request for the item.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync.EnableOutputBuffering">
            <summary>
            Determines whether engine can buffer content to calculate content length.
            </summary>
            <returns>
            Boolean indicating whether content shall be buffered to calculated content length.
            Engine will look at this property only if <see cref="!:DavEngine.CalculateContentLength"/> is true.
            </returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync.EnableOutputDebugLogging">
            <summary>
            Determines whether output produces by this handler shall be logged if debug logging
            is enabled.
            </summary>
            <returns>Boolean indicating whether output shall be logged in debug mode.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync.EnableInputDebugLogging">
            <summary>
            Determines whether input read by this handler shall be logged if debug logging is enabled.
            </summary>
            <returns>Boolean indicating whether input shall be logged in debug mode.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Sharing">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler">
            <summary>
             An HTTP request using the MKCALENDAR method creates a new calendar collection resource.
            </summary>
            <remarks>
            The implementation is not optimal, because it makes extra call to GetHierarchyItem in 
            case url is not eaquel to displayname
            http://tools.ietf.org/html/rfc4791#section-5.3.1
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler.ProcessRequestAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            When creating new calendars iCal submits request that looks like the following:
            MKCALENDAR https://base/calendars/Volodymyr/423C82A5-CB6F-475D-A564-3AA73C5EAA39/
            but specifies display name in the displayname property, which is totally according to RFC
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler">
            <summary>
            Provides point of extension to OPTIONS request.
            </summary>
            <remarks>
            If you need to implement your own extension to WebDAV and add token to DAV header in OPTIONS response,
            implement this interface and register it with <see cref="!:DavEngine.RegisterOptionsHandler"/> method
            passing token as first argument to it.
            When building DAV header engine will call all registered options handlers to determine if this particular
            options is available for the item.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IOptionsHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            The method is called to determine if the option is available for the item and shall be
            enlisted in DAV header for OPTIONS response.
            </summary>
            <param name="item">Item for which request is made.</param>
            <returns><c>true</c>if option token shall be enlisted.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync">
            <summary>
            Provides point of extension to PROPFIND, PROPPATCH requests.
            </summary>
            <remarks>
            If you need to implement your own live property,
            implement this interface and register it with <see cref="!:DavEngine.RegisterPropertyHandler"/> method.
            Engine will call this handler when it needs to read/write the property.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.WriteAsync(System.Xml.XmlTextWriter,ITHit.WebDAV.Server.IHierarchyItemAsync,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes property value to xml writer.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlTextWriter"/> to which to write property value.</param>
            <param name="item">Item for which to retrieve property.</param>
            <param name="context">Context.</param>        
            <remarks>
            Property writer shall retrieve and validate all values first and only then write anything to writer.
            Otherwise exception may be thrown while retrieving properties and output XML will be broken.
            </remarks>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.UpdateAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync,System.Xml.XmlElement)">
            <summary>
            Updates value of property.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item in which to update property.</param>
            <param name="value">Xml with property value.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this property can be set/retrieved form an item.
            </summary>
            <param name="item">Item to determine whether property applies to it.</param>
            <returns><c>true</c>if the property applies to the item.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.IsReadonly">
            <summary>
            Gets a value indicating whether the property is readonly and cannot be updated.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync.IncludeInAllProp">
            <summary>
            Gets a value indicating whether the property shall be included in 'allprop' response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.AllowedSharingModes">
            <summary>
            Defines allowed sharing modes for calendar.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.Invite">
            <summary>
            Used to show to whom a calendar has been shared.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CardDav.AddressbookHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            address book collections owned by the associated principal
            resource.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.CalendarHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            calendar collections owned by the associated principal resource.
            </summary>
            <remarks>
            <para>
            This property SHOULD be defined on a principal
            resource.  If defined, it MAY be protected and SHOULD NOT be
            returned by a PROPFIND DAV:allprop request (as defined in Section
            12.14.1 of [RFC2518]).
            </para>
            <para>
            The CALDAV:calendar-home-set property is meant to allow
             users to easily find the calendar collections owned by the
             principal.  Typically, users will group all the calendar
             collections that they own under a common collection.  This
             property specifies the URL of collections that are either calendar
             collections or ordinary collections that have child or descendant
             calendar collections owned by the principal.
             </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.MultigetReportHandler">
            <summary>
            Base class for processing <b>calendar-multiget</b> report and <b>addressbook-multiget</b> report.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync">
            <summary>
            Provides point of extension to REPORT requests.
            </summary>
            <remarks>
            If you need to implement your own report,
            implement this interface and register it with <see cref="!:DavEngine.RegisterReportHandler"/> method.
            Engine will call this handler when it needs to execute a report.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this report can be executed for an item.
            </summary>
            <param name="item">Item to determine whether the report applies to it.</param>
            <returns><c>true</c>if the report applies to the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync.HandleReportAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync,System.Xml.XmlElement)">
            <summary>
            Generates report response.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item for which request is sent.</param>
            <param name="reportElement">Root request XML element.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarMultigetReportHandler.GetHierarchyItemsAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarQueryReportHandler">
            <summary>
            This report handler implementation is a quick solution to support calendar on iOS and CalDAVSync on Android. Is is not performance-efficient.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarQueryReportHandler.GetDepth(ITHit.WebDAV.Server.Extensibility.DavRequest)">
            <summary>
            The request MAY include a Depth header.  If no Depth header is included, Depth:0 is assumed.
            http://tools.ietf.org/html/rfc4791#section-7.8
            </summary>
            <returns>
            This implementation is different from the ITHit.WebDAV.Server.Impl.Util.DavRequestExtensions.GetDepth() 
            implementation. This one returns 1 in case Depth heder is not present.
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CardDav.AddressbookMultigetReportHandler.GetHierarchyItemsAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Url">
            <summary>
            TODO: Update summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.LogFlagsEnum">
            <summary>
            Logging options.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LogFlagsEnum.LogGetResponseBody">
            <summary>
            If this flag is set the GET response body will be logged.
            </summary>
            <remarks>
            <para>
            The body of the GET response may be very large and often not human readable. 
            </para>
            <para>
            It make sense to enable GET body logging for CalDAV and CardDAV servers and disable in other cases.
            </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.LogFlagsEnum.LogPutRequestBody">
            <summary>
            If this flag is set the PUT request body will be logged.
            </summary>
            <remarks>
            <para>
            The body of the PUT request may be very large and often not human readable. 
            </para>
            <para>
            It make sense to enable PUT body logging for CalDAV and CardDAV servers and disable in other cases.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.ISearchAsync">
            <summary>
            Represents the item that supports search according to DASL standard.
            </summary>
            <remarks>
            <para>
            Implement this interface on folders that suppoort search. When search request is 
            recived the <see cref="!:DavEngine"/> calls <see cref="!:ISearch.Search"/> method.
            </para>
            <para>
            If this interface is found on folder items, your server will include <b>DASL: &lt;DAV:basicsearch&gt;</b> 
            header and <b>SEARCH</b> token in <b>Allow</b> header in response to <b>OPTIONS</b> requests. The WebDAV clients that support DASL 
            search, including IT Hit Ajax File Browser, may rely on this header and token to display search user interface.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<IHierarchyItem> Search(string searchString, SearchOptions options)
{
    // search both in file name and content
    string commandText = 
        @"SELECT System.ItemPathDisplay FROM SystemIndex " +
        @"WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " +
        @"ORDER BY System.Search.Rank DESC";

    commandText = PrepareCommand(commandText,
        "@Path", this.dirInfo.FullName,
        "@Name", searchString,
        "@Content", searchString);

    List<string> foundItems = new List<string>();
    try
    {
        // Sending SQL request to Windows Search. To get search results file system indexing must be enabled.
        // To find how to enable indexing follow this link: http://windows.microsoft.com/en-us/windows/improve-windows-searches-using-index-faq
        using (OleDbConnection connection = new OleDbConnection(windowsSearchProvider))
        using (OleDbCommand command = new OleDbCommand(commandText, connection))
        {
            connection.Open();
            using (OleDbDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                    foundItems.Add(reader.GetString(0));
            }
        }
    }
    catch (OleDbException ex) // explaining OleDbException
    {
        context.Logger.LogError(ex.Message, ex);
        switch (ex.ErrorCode)
        {
            case -2147217900: throw new DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT);
            default:          throw new DavException("Unknown error.", DavStatus.INTERNAL_ERROR);
        }
    }
    return foundItems.Select(GetRelativePath).Select(context.GetHierarchyItem);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Search.ISearchAsync.SearchAsync(System.String,ITHit.WebDAV.Server.Search.SearchOptions)">
            <summary>
            Returns list of items that correspond to search request. 
            </summary>
            <param name="searchString">A phrase to search.</param>
            <param name="options">Search parameters.</param>
            <returns>List of <see cref="!:IHierarchyItem"/> satisfying the search parameters or empty list.</returns>
            <remarks>
            <para>
            This method is called by <see cref="!:DavEngine"/> when client application is sending search request. 
            In your implementation you must return the list of items that correspond to the requested search phrase and options.
            </para>
            <para>The search phrase may contain wildcards:</para>
            <para>
            To indicate one or more characters the '%' is passed in search string.
            </para>
            <para>
            To indicate exactly one character the '_' is passed in search string.
            </para>
            <para>To include '%', '_' and '\' characters in the search string thay are escaped with '\' character.</para>
            <para>Note that IT Hit Ajax File Browser is using '*' and '?' as wildcard characters. In case included in search they are replaced with '%' and '_'.</para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<IHierarchyItem> Search(string searchString, SearchOptions options)
{
    // search both in file name and content
    string commandText = 
        @"SELECT System.ItemPathDisplay FROM SystemIndex " +
        @"WHERE scope ='file:@Path' AND (System.ItemNameDisplay LIKE '@Name' OR FREETEXT('""@Content""')) " +
        @"ORDER BY System.Search.Rank DESC";

    commandText = PrepareCommand(commandText,
        "@Path", this.dirInfo.FullName,
        "@Name", searchString,
        "@Content", searchString);

    List<string> foundItems = new List<string>();
    try
    {
        // Sending SQL request to Windows Search. To get search results file system indexing must be enabled.
        // To find how to enable indexing follow this link: http://windows.microsoft.com/en-us/windows/improve-windows-searches-using-index-faq
        using (OleDbConnection connection = new OleDbConnection(windowsSearchProvider))
        using (OleDbCommand command = new OleDbCommand(commandText, connection))
        {
            connection.Open();
            using (OleDbDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                    foundItems.Add(reader.GetString(0));
            }
        }
    }
    catch (OleDbException ex) // explaining OleDbException
    {
        context.Logger.LogError(ex.Message, ex);
        switch (ex.ErrorCode)
        {
            case -2147217900: throw new DavException("Illegal symbols in search phrase.", DavStatus.CONFLICT);
            default:          throw new DavException("Unknown error.", DavStatus.INTERNAL_ERROR);
        }
    }
    return foundItems.Select(GetRelativePath).Select(context.GetHierarchyItem);
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">
            <summary>
            Indicates that an operation failed due to insufficient privileges for one or more items.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavException">
            <summary>
            Exception which can be thrown by WebDAV interface implementations.
            </summary>
            <remarks>
            There are some other exceptions derived from this one which contain specific
            fields, like <see cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException"/>.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor">
            <summary>
            Initializes a new instance of the DavException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message and a
            reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
            (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with serialized data. 
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the
            exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the
            source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or HResult is zero (0).</exception>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, status
            code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, details
            and status code.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message,
            description, status code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
             or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Some methods, like "HEAD" forbid any content in response, this parameter will
            be <c>false</c> in this 
            case and nothing shall be written in the response.</param>
            <remarks>
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.RenderInline(System.Xml.XmlTextWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlTextWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in <see cref="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)"/>
            method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.ErrorDetails">
            <summary>
            Contains XML element name and namespace which will be written to the response body.
            It provides more information about error which can be interpreted by clients.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.Code">
            <summary>
            HTTP status code and description that will be sent to client.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String,System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
            <param name="path">Item path.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.AddRequiredPrivilege(System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Adds privilege that is required to perform the operation on the item.
            </summary>
            <param name="path">Item which misses the privilege.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Whether contents shall be written to output.</param>
            <remarks>
            If exception is rendered 'inline', then it shall write only it's body.
            Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            Otherwise full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RenderInline(System.Xml.XmlTextWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Renders exception as part of multistatus exception.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlTextWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in
            <see cref="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)"/> method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RequiredPrivileges">
            <summary>
            List of &lt;item path, missing privilege> pairs.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.UpdateFileDataAsync(ITHit.WebDAV.Server.Extensibility.DavRequest,ITHit.WebDAV.Server.IContentAsync,System.IO.Stream,System.Int64,System.String)">
            <summary>
            Returns true if file was updated completely (or last chunk written),
            so file can be automatically checked in.
            </summary>
            <param name="request"></param>
            <param name="file"></param>
            <param name="inputStream"></param>
            <param name="length"></param>
            <param name="contentType"></param>
            <returns></returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo">
            <summary>
            Information about file being uploaded.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.GetParentAsync">
            <summary>
            Returns parent folder and name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Name">
            <summary>
            Gets name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Stream">
            <summary>
            Gets upload stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentType">
            <summary>
            Gets file's content type.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentLength">
            <summary>
            Gets content length.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CancelUploadDavHandler">
            <summary>
            Summary description for CancelUploadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IisRequest">
            <summary>
            Represents an incoming HTTP request for IIS-hosted server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IisResponse">
            <summary>
            Represents HTTP response for IIS-hosted server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockResult">
            <summary>
            Result of <see cref="!:ILock.Lock"/> operation. 
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockResult.#ctor(System.String,System.TimeSpan)">
            <summary>
            Initializes a new instance of the LockResult class.
            </summary>
            <param name="token">Lock token associated with a lock.</param>
            <param name="timeOut">Timeout value. <c>TimeSpan.MaxValue</c> means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.Token">
            <summary>
            Gets/sets lock token associated with the lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.TimeOut">
            <summary>
            Gets/Sets timeout value;
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyName">
            <summary>
            Describes property name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_NAME">
            <summary>
            Refers to <see cref="!:IVersion.VersionName"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetAcl"/> / <see cref="!:IAclHierarchyItem.SetAcl"/>.
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL_RESTRICTIONS">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetAclRestrictions"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ALTERNATE_URI_SET">
            <summary>
            Is not supported.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETETAG">
            <summary>
            Refers to <see cref="!:IContent.Etag"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.COMMENT">
            <summary>
            Refers to <see cref="!:IDeltaVItem.GetComment"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATIONDATE">
            <summary>
            Refers to <see cref="!:IHierarchyItem.Created"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATOR_DISPLAYNAME">
            <summary>
            Refers to <see cref="!:IDeltaVItem.GetCreatorDisplayName"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetCurrentUserPrivilegeSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLANGUAGE">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLENGTH">
            <summary>
            Refers to <see cref="!:IContent.ContentLength"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTTYPE">
            <summary>
            Refers to <see cref="!:IContent.ContentType"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETLASTMODIFIED">
            <summary>
            Refers to <see cref="!:IHierarchyItem.Modified"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetGroup"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBER_SET">
            <summary>
            Refers to <see cref="!:IPrincipal.GetGroupMembers"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBERSHIP">
            <summary>
            Refers to <see cref="!:IPrincipal.GetGroupMembership"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.INHERITED_ACL_SET">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetInheritedAclSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.LOCKDISCOVERY">
            <summary>
            Refers to <see cref="!:ILock.GetActiveLocks"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.OWNER">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetOwner"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_COLLECTION_SET">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetPrincipalCollectionSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_URL">
            <summary>
            Is not directly supported. Is the same as <see cref="!:IHierarchyItem.Path"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEDGE_SET">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetSupportedPrivilegeSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.AUTO_VERSION">
            <summary>
            Refers to <see cref="!:IVersionableItem.GetAutoVersion"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_HISTORY">
            <summary>
            Refers to <see cref="!:IVersionableItem.VersionHistory"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetSupportedPrivilegeSet"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRINCIPAL">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetCurrentUserPrincipal"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_USED_BYTES">
            <summary>
            Refers to <see cref="!:IQuota.GetUsedBytes()"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_AVAILABLE_BYTES">
            <summary>
            Refers to <see cref="!:IQuota.GetAvailableBytes()"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property local name.</param>
            <param name="propNamespace">Property namespace.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.ToString">
            <summary>
            Returns property name as string.
            </summary>
            <returns>String representation.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="other"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Equality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Equality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Inequality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Unequality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(System.Object)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="obj"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>       
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>        
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Namespace">
            <summary>
            Property namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Name">
            <summary>
            Property local name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.PostUploadProgressModule">
            <summary>
            Enables POST upload with progress of files to IIS/ASP.NET.
            </summary>
            <remarks>
            <para>
            You need to use this module if you are using AJAX File Browser with Internet Explorer 9 and earlier.
            </para>
            </remarks>
            <example>
                Example of configuration for IIS:
            <code>
            <![CDATA[
                <httpModules>
                    <remove name="FileAuthorization"/>
                    <add 
                        name="PostUploadProgressModule"
                        type="ITHit.WebDAV.Server.PostUploadProgressModule, ITHit.WebDAV.Server" />
                </httpModules>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.PostUploadProgressModule.Init(System.Web.HttpApplication)">
            <summary>
            Initializes a module and prepares it to handle requests.
            </summary>
            <param name="context">An <see cref="T:System.Web.HttpApplication"></see> that provides access to the
             methods, properties, and events common to all application objects within an ASP.NET application </param>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.PostUploadProgressModule.Dispose">
            <summary>
            Disposes of the files (other than memory) used by the module that implements
            <see cref="T:System.Web.IHttpModule"></see>.
            </summary>
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync">
             <summary>
             Implemented on files and folders to report upload progress.
             </summary>
             <remarks>
             <para>This interface should be implemented on files that can provide upload progress information to client
             application. Optionally it can be implemented on folder items.</para>
             <para>When implementing this interface you may need to configure <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> and 
             <see cref="T:ITHit.WebDAV.Server.PostUploadProgressModule"/> module in your web.config file if your WebDAV server is hosted in IIS/ASP.NET.</para>
             <para>
             Usually client application requests upload progress in following cases: 
             <list type="bullet">
             <item><description>If connection was broken (paused) and client would like to restore upload. Client will
             submit upload-progress request to get number of bytes successfully saved on server side and will start the
             upload from the next byte. You must add <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> in your web.config to support this 
             scenario if your application is running ASP.NET 2.0 pool. The <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is 
             not required if you are using ASP.NET 4.0 pool and is ignored if you include it in web.config</description></item>
             <item><description>When client application requires information about how much of the uploaded file
             was processed on server side. Usually this is required by Microsoft Internet Explorer 9 and earlier only.  
             IE 9 and earlier does not have any information about how much of the file was submitted to server. 
             It will submit upload-progress request to update its upload progress bar from time to time. You must 
             add <see cref="T:ITHit.WebDAV.Server.PostUploadProgressModule"/> in your web.config to support this scenario.</description></item>
             </list>
             </para>
             <para>
             To check if folder or file supports upload-progress report and resumable upload feature the client application
             will submit OPTIONS request to that item. If the item implements <c>IUploadProgress</c> interface Engine will
             add 'resumable-upload' token to DAV response header. See example below.
             </para>
             <para>
             To get information about file upload progress client will submit REPORT request to that file with upload
             progress type. The Engine will call <see cref="!:GetUploadProgress"/> method in this case. You will return an
             <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains single item (this file implementing <see cref="!:IResumableUpload"/>) from
             <see cref="!:GetUploadProgress"/> method implementation. The engine will extract necessary info from the
             returned <see cref="!:IResumableUpload"/> interface and return it to client. The response will contain XML
              with information about upload progress for the requested file: url of the file, number or bytes uploaded,
             total size of the file and time when last save operation occurred. 
             </para>
             <para>The response returned by server Engine to client is a REPORT multistatus response that contains three
             properties for each file:
             </para>
             <para>
             <list type="bullet">
             <item> <description><b>ithit:bytes-uploaded</b> - integer value. Number of bytes uploaded and saved in
             persistent storage. If upload was broken or paused the client application will usually start upload from the
             next byte returned in this property.</description></item>
             <item> <description><b>ithit:last-chunk-saved</b> - date\timein in RFC 1123 format. Indicates when last chunk
             was saved. May be used in admin applications and automatic maintenance tools to remove files that were not
             fully uploaded.</description></item>
             <item> <description><b>ithit:total-content-length</b> - integer value. Total file size that is being uploaded
             to server. Thin client applications may use this value for displaying upload progress.</description></item>
             </list>
             </para>
             <para>See example of upload progress report below.</para>
             <para>
             The client application can also submit upload-progress REPORT request to a folder. In this case from your
             <see cref="!:GetUploadProgress"/> property implementation you will return IEnumerable containing files that are being uploaded
             that reside in the folder's subtree. The response XML will contain info about each file from the <see cref="T:System.Collections.Generic.IEnumerable`1"/> in a
             separate response tag. See example below.
             </para>
             <para>
             If item does not support upload-progress report and server is based on IT Hit WebDAV Server Engine the server
             will respond with '403 Forbidden' to
             REPORT request. The body will contain &lt;A:supported-report xmlns="DAV:"/&gt;  element. If server does not support
             REPORT verb you will get 405 Method Not Allowed response.
             </para>
             </remarks>
             <example>
             <para>
             OPTIONS request is used to determine if folder or file supports resumable upload.
             <para>Request:</para>
             <code>
             <![CDATA[
             OPTIONS /Folder/ HTTP/1.1
             Host: davserver
             Content-Length: 0
             ]]>
             </code>
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 200 OK
             Content-Length: 0
             Accept-Ranges: none
             DAV: 1, 2, resumable-upload
             Public: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             Allow: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over file contains  info about single item.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:">
             <D:response>
                <D:href>http://server:8580/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>    
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over folder contains  info about all files being uploaded to subtree.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /folder HTTP/1.1
             Host: http://server:8580/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:" xmlns:ithit="ithit">
             <D:response>
                <D:href>http://server:8580/folder/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
             <D:response>
                <D:href>http://server:8580/folder/nestedfolder/AnotherLargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>47</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:16:12 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>6398</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             If item on server based on IT Hit WebDAV Server Engine does not support upload-progress the server will respond
             with 403 Forbidden response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 403 Forbidden
             Content-Length: 31
             Content-Type: application/xml;charset=UTF-8
            
             <supported-report xmlns="DAV"/>
             ]]>
             </code>
             </para>
             <para>
             If server does not support REPORT verb (often non-IT Hit Engine) you will get 405 Method Not Allowed response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 405 Method Not Allowed
             Content-Length: 0
             Content-Type: application/xml;charset=UTF-8
            
             ]]>
             </code>
             </para>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgressAsync.GetUploadProgressAsync">
            <summary>Gets IEnumerable with items that are being uploaded to this item subtree.</summary>
            <remarks>
            <para>
            Returns <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a single item if implemented on file items. Return all items that are being uploaded to
            this subtree if implemented on folder items.
            </para>
            <para>
            Engine calls <see cref="!:IHierarchyItem.Path"/>, 
            <see cref="!:IResumableUpload.LastChunkSaved"/>, 
            <see cref="!:IResumableUpload.BytesUploaded"/>, 
            <see cref="!:IResumableUpload.TotalContentLength"/> and returns this information to
            client.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IUploadProgress.GetUploadProgress&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule">
            <summary>
            Enables non-cached upload of files to IIS/ASP.NET.
            </summary>
            <remarks>
            <para>
            Always use this module if you implement resumable upload features and your WebDAV server is hosted in 
            application that uses ASP.NET 2.0 pool. It is recommended to enable this module even if you do not need any resumable upload fetures but 
            host your server is using ASP.NET 2.0 pool. This module is not required for application running in ASP.NET 4.0 pool or later and is ignored if enabled.
            </para>
            <para>
            Without this module when a file is being uploaded to the server running as ASP.NET application with 2.0 pool, the file 
            will be first saved to temporary upload folder. Only when entire file is uploaded it becomes available for .NET
            user code. <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> eliminates this 
            problem passing file content directly to Engine. This problem is specific to ASP.NET/IIS and you do not need 
            this module when creating HttpListener-based server or if you are using ASP.NET 4.0 pool.
            </para>
            <para>
            <b>Note</b>: Always use <see cref="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Web.HttpContext)"/> overloaded constructor when utilizing 
            this module.
            </para>
            </remarks>
            <example>
            <para>Example of configuraiton for IIS 8 integrated mode and IIS 7.x integrated mode:</para>
            <code>
            <![CDATA[
            <system.webServer>
                <modules>
                    <add 
                        name="PutUploadProgressAndResumeModule"
                        type="ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule, ITHit.WebDAV.Server"
                        preCondition="integratedMode" />
                </modules>
            </system.webServer>
             ]]>
            </code>
            </example>
            <example>
                Example of configuration for IIS 8 classic mode, IIS 7.x classic mode, IIS 6 and IIS 5.1:
            <code>
            <![CDATA[
            <system.web>
                <httpModules>
                    <remove name="FileAuthorization"/>
                    <add 
                        name="PutUploadProgressAndResumeModule"
                        type="ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule, ITHit.WebDAV.Server" />
                </httpModules>
            </system.web>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule.Init(System.Web.HttpApplication)">
            <summary>
            Initializes a module and prepares it to handle requests.
            </summary>
            <param name="context">An <see cref="T:System.Web.HttpApplication"></see> that provides access to the
            methods, properties, and events common to all application objects within an ASP.NET application </param>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule.Dispose">
            <summary>
            Disposes of the files (other than memory) used by the module that implements 
            <see cref="T:System.Web.IHttpModule"/>.
            </summary>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.ReadTillSeparatorInChunks(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            After this method <see cref="F:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.readCachedData"/> contains cached data right after next boundary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext">
            <summary>
            Contains stream of data in case of POST and PUT when <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is used.
            </summary>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.GetStream">
            <summary>
            Returns content stream of current request.
            </summary>
            <returns>Content stream.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.IsAvailable">
            <summary>
            Determines if <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is used and <see cref="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.GetStream"/>
            method can be called.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.#ctor(System.Web.HttpWorkerRequest)">
            <summary>   
            Constructor.   
            </summary>   
            <param name="request">The original worker request.</param>           
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetTotalEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUriPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetQueryString">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRawUrl">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetHttpVerbName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetHttpVersion">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemoteAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemotePort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetLocalAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetLocalPort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetKnownRequestHeader(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendStatus(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendKnownResponseHeader(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendUnknownResponseHeader(System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.String,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.IntPtr,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.FlushResponse(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.EndOfRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsEntireEntityBodyIsPreloaded">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.CloseConnection">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetQueryStringRawBytes">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemoteName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetServerName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetConnectionID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUrlContextID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPoolID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRequestReason">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUserToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetVirtualPathToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsSecure">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetProtocol">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetFilePath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetFilePathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPathInfo">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeader(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeaders">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetServerVariable(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetBytesRead">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MapPath(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.IntPtr,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SetEndOfSendNotification(System.Web.HttpWorkerRequest.EndOfSendNotification,System.Object)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.HeadersSent">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsClientConnected">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificate">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidFrom">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidUntil">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateBinaryIssuer">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateEncoding">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificatePublicKey">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ToString">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MachineConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.RootWebConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MachineInstallDirectory">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.RequestTraceIdentifier">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav">
            <summary>
            DeltaV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav.PropertyNames">
            <summary>
            DeltaV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.AutoVersion">
            <summary>
            Auto versioning modes supported by item to be used with versioning unaware clients.
            </summary>
            <remarks>
            <para>
            This enumeration determines how engine responds to WebDAV client requests that attempt to modify 
            checked-in items content or properties. Each item that support versioning can function in one of the following 
            auto-versioning modes:
            </para>
            <para>
            <b>NoAutoVersioning Mode.</b>
            In this mode item must be checked-out before modifications. Clients that does not support DeltaV will not be
            able to modify checked-in items.
            </para>
            <para>
            <b>CheckOutCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. Potentially many
            versions may be created. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
            <item><description>Auto check-out performed.</description></item>
            <item><description>Modifications performed.</description></item>
            <item><description>Auto check-in performed.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).</description></item>
            </list>
            </para>
            <para>
            <b>CheckOutUnlockedCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If WebDAV client
            locks the item prior to update, the item will be checked in during unlock. This mode reduces the number of
            versions created by versioning unaware clients. The item is never left checked-out. This mode is recommended if
            you need to support both Class 1 and Class 2 WebDAV clients. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                <item><description>Auto check-in performed if item not locked.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).
            <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
            </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>CheckOut Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If the item 
            was not locked before the update it will be left in checked-out state after modifications. Workflow for
            versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (optional). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>LockedCheckOut Mode.</b>
            Only WebDAV client applications that lock item before the update will be able to modify checked-in item. 
            This mode minimizes amount of versions created by versioning unaware clients. Class 1 WebDAV applications will 
            not be able to modify checked-in items. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (required).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (required). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.NoAutoVersioning">
            <summary>
            Auto versioning is not supported for checked-in items. Modification requests of versioning unaware clients
            will fail if item was not checked-out.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutCheckIn">
            <summary>
            Before any item modification (such as changing content or properties) 
            by versioning unaware client  engine will call <see cref="!:IVersionableItem.CheckOut"/>. After the item is
            modified <see cref="!:IVersionableItem.CheckIn"/> will be called.
            <para>
            This potentially can create a lot of versions.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutUnlockedCheckIn">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="!:IVersionableItem.CheckOut"/>. If item is not locked engine
            will call <see cref="!:IVersionableItem.CheckIn"/> when modification completes.
            <para>
            If item is locked, <see cref="!:IVersionableItem.CheckIn"/> will be called before the
            <see cref="!:ILock.Unlock"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOut">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="!:IVersionableItem.CheckOut"/>. The <see cref="!:IVersionableItem.CheckIn"/> will not be called.
            <para>
            If item is locked, <see cref="!:IVersionableItem.CheckIn"/> will be called before the
            <see cref="!:ILock.Unlock"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.LockedCheckOut">
            <summary>
            If client tries to modify locked checked-in item, engine will automatically call
            <see cref="!:IVersionableItem.CheckOut"/>.
            <para>
            <see cref="!:IVersionableItem.CheckIn"/> will be called before the <see cref="!:ILock.Unlock"/>.
            If lock expires you must check-in item manually.
            </para>
            <para>
            If item is not locked - update request will fail.
            </para>
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync">
            <summary>
            Base interface for items that support versioning and item versions (DeltaV items).
            </summary>
            <remarks>
            This interface defines properties common to all items that support versioning and item versions. 
            It provides the means of getting and setting comments and author name when creating new version. 
            The author of the version is set and get via <see cref="!:SetCreatorDisplayName"/>,
            <see cref="!:GetCreatorDisplayName"/>methods and comment via <see cref="!:GetComment"/>,
            <see cref="!:SetComment"/> methods.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCommentAsync(System.String)">
            <summary>
            Sets a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <param name="comment">Comment string.</param>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void SetComment(string comment)
{
    context.ExecuteNonQuery(
        "UPDATE Version SET Comment = @Comment WHERE VersionId = @VersionId",
        "@VersionId", versionId,
        "@Comment", comment);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCommentAsync">
            <summary>
            Retrieves a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <returns>Comment string.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public string GetComment()
{
    return context.ExecuteScalar<string>(
        "SELECT Comment FROM Version WHERE VersionId = @VersionId",
        "@VersionId", VersionId);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.SetCreatorDisplayNameAsync(System.String)">
            <summary>
            Sets display name of the user that created this item.
            </summary>
            <remarks>
            Sets description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <param name="creatorDisplayName">String representing author name.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void SetCreatorDisplayName(string creatorName)
{
    context.ExecuteNonQuery(
        @"UPDATE Version SET CreatorDisplayName = @CreatorDisplayName
          WHERE VersionId = @VersionId",
        "@VersionId", VersionId,
        "@CreatorDisplayName", creatorName);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItemAsync.GetCreatorDisplayNameAsync">
            <summary>
            Retrieves display name of the user that created this item.
            </summary>
            <remarks>
            Retrieves description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <returns>String representing author name.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public string GetCreatorDisplayName()
{
    return context.ExecuteScalar<string>(
        "SELECT CreatorDisplayName FROM Version WHERE VersionId = @VersionId",
        "@VersionId", VersionId);
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IHistoryAsync">
            <summary>
            Contains all versions of a particular version-controlled item.
            </summary>
            <remarks>
            The important property of this interface is <see cref="T:System.IO.Path"/> property inherited from IHierarchyItem. 
            The url returned by this property is used by client applications to remove item from version control. 
            The client application submits DELETE WebDAV request to this url and the engine calls
            <see cref="!:IVersionableItem.PutUnderVersionControl"/> 
            passing <b>false</b> as a parameter. In your <see cref="!:IVersionableItem.PutUnderVersionControl"/> you will
            usually delete all versions. 
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetCurrentVersionAsync">
            <summary>
            Retrieves current item version.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IVersion GetCurrentVersion()
{
    string command = 
        @"SELECT VersionId, ItemId, VersionNumber, Name, Created, SerialNumber
          FROM Version
          WHERE ItemId = @ItemId AND VersionNumber = 
               (SELECT MAX(VersionNumber) FROM Version WHERE ItemId = @ItemId)";

    return context.ExecuteVersion(
        path.Remove(path.IndexOf('?')),
        command,
        "@ItemId", itemId).FirstOrDefault();
}

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetVersionSetAsync(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Retrieves all versions of current item.
            </summary>
            <param name="propNames">Names of properties which engine will request from the returned items.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<IVersion> GetVersionSet(IList<PropertyName> propNames)
{
    string command = 
        @"SELECT VersionId, ItemId, VersionNumber, Name, Created, SerialNumber
          FROM Version
          WHERE ItemId = @ItemId";

    return context.ExecuteVersion(
        path.Remove(path.IndexOf('?')),
        command,
        "@ItemId", itemId);
}

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistoryAsync.GetRootVersionAsync">
            <summary>
            Retrieves item's root version.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IVersion GetRootVersion()
{
    string command = 
        @"SELECT VersionId, ItemId, VersionNumber, Name, Created, SerialNumber
          FROM Version
          WHERE ItemId = @ItemId AND VersionNumber =
                           (SELECT MIN(VersionNumber) FROM Version WHERE ItemId = @ItemId)";

    return context.ExecuteVersion(
        path.Remove(path.IndexOf('?')),
        command,
        "@ItemId", itemId).FirstOrDefault();
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionAsync">
            <summary>
            Represents single item version.
            </summary>
            <remarks>
            <para>
            Defines the properties and methods that item version must implement. In addition to methods and properties
            provided by <see cref="!:IDeltaVItem"/> this interface also provides methods for getting version name, next
            version and previous version. 
            </para>
            <para>
            Usually you will implement <b>IVersion</b> interface for your file version objects together with
            <see cref="!:IFile"/> interface. While <b>IFile</b> interface is optional for file versions it may be useful if
            your DeltaV client application will request content of the file version. In this case 
            <see cref="!:IContent.Read"/>, <see cref="!:IContent.ContentLength"/> and <see cref="!:IContent.ContentType"/> 
            members of the <see cref="!:IFile"/> interface will be requested by the engine. Copying, moving, updating 
            properties and content is not allowed for a version, your <see cref="!:IHierarchyItem.CopyTo"/>, 
            <see cref="!:IHierarchyItem.MoveTo"/>, <see cref="!:IHierarchyItem.UpdateProperties"/> and
            <see cref="!:IContent.Write"/> implementations must throw <see cref="T:ITHit.WebDAV.Server.DavException"/> with status 
            <see cref="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED"/>.
            </para>
            <para>
            Generally from your <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionAsync.VersionName"/> implementation you can return any string suitable for 
            displaying to user as a version or the hierarchy item. This string must be unique among versions for this 
            hierarchy item. Usually you will return “1”, “2”, etc or “3.1”, “3.4”, etc. 
            </para>
            <para>
            <see cref="!:GetSuccessor"/> and <see cref="!:GetPredecessor"/> methods of this interface return next and previous
            version for the item. The <see cref="!:GetVersionableItem"/> method returns the hierarchy item (usually file) to
            which this version belongs.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetSuccessorAsync">
            <summary>
            Next version or null if no next version exists.
            </summary>
            <returns>Version item representing next version
             in the list of versions or null if no next version exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IVersion GetSuccessor()
{
    string command = 
        @"SELECT VersionId, ItemId, VersionNumber, Name, Created, SerialNumber
          FROM Version
          WHERE (ItemId = @ItemId) AND (VersionNumber =
                (SELECT MIN(VersionNumber)
                 FROM Version
                 WHERE (ItemId = @ItemId) AND (VersionNumber > @VersionNumber)))";
    
    return context.ExecuteVersion(
        path.Remove(path.IndexOf('?')),
        command,
        "@ItemId", itemId,
        "@VersionNumber", versionNumber).FirstOrDefault();
}

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetPredecessorAsync">
            <summary>
            Previous version or null if no previous version exists.
            </summary>
            <returns>Version item representing previous version in the list of versions or null if no previous version
            exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IVersion GetPredecessor()
{
    string command = 
        @"SELECT VersionId, ItemId, VersionNumber, Name, Created, SerialNumber
          FROM Version
          WHERE (ItemId = @ItemId) AND (VersionNumber =
                (SELECT MAX(VersionNumber)
                 FROM Version
                 WHERE (ItemId = @ItemId) AND (VersionNumber < @VersionNumber)))";

    return context.ExecuteVersion(
        path.Remove(path.IndexOf('?')),
        command,
        "@ItemId", itemId,
        "@VersionNumber", versionNumber).FirstOrDefault();
}

]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionAsync.GetVersionableItemAsync">
            <summary>
            Hierarchy item for this version.
            </summary>
            <value>Hierarchy item for this version.</value>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersion.GetVersionableItem&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionAsync.VersionName">
            <summary>
            Name of the version.
            </summary>
            <value>Name of the version.</value>
            <remarks>
            Must be unique among version items for a given hierarchy item. This string is intended for display
            for a user.
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public string VersionName
{
    get { return "V" + this.versionNumber; }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync">
            <summary>
            This interface must be implemented on items that support versioning.
            </summary>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version control
            engine calls <see cref="!:PutUnderVersionControl"/> method passing <b>true</b> as a parameter.
            In your <see cref="!:PutUnderVersionControl"/> implementation you must create a new version. The content and
            properties of the new version must be copied from this item. After the call to 
            <see cref="!:PutUnderVersionControl"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must point to the object 
            implementing <see cref="!:IHistory"/> interface that will contain single version. The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut"/> 
            property must return <b>false</b>.
            </para>
            <para>
            <b>If item is under version control it mast always have at last one version in its versions list.</b>
            </para>
            <para>
            After the item had been put under version control client can issue checkout command.
            In your <see cref="!:CheckOut"/> implementation you will mark item as checked-out and allow item modifications.
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            <para>
            Finally client issues check-in command or discards changes issuing uncheck-out command.
            In your <see cref="!:CheckIn"/> implementation you will create a new version. The content and properties of the
            new version must be copied from this item. The item must be marked as checked-in.
            In your <see cref="!:UnCheckOut"/> implementation you will discard changes and restore pre-checkout state.
            Content and properties must be copied from current version to this item. The item must be marked as checked-in.
            </para>
            <para>
            The typical versioning workflow:
            <list type="number">
            <item><description>Engine calls <see cref="!:IVersionableItem.PutUnderVersionControl"/>. Create new version,
            copy content and properties from this item to new version.</description></item>
            <item><description>Engine calls <see cref="!:IVersionableItem.CheckOut"/>.
            Mark item as checked-out.</description></item>
            <item><description>Engine calls <see cref="!:IContent.Write"/> or <see cref="!:IHierarchyItem.UpdateProperties"/>.
            Modify item content and properties.</description></item>
            <item><description>Engine calls <see cref="!:IVersionableItem.CheckIn"/> or
            <see cref="!:IVersionableItem.UnCheckOut"/>. For <see cref="!:CheckIn"/> - create new version, copy content and
            properties from this item to new version. For <see cref="!:UnCheckOut"/> - copy content and properties from
            current version to this item. Mark item as checked-in.</description></item>
            </list>
            </para>
            <para>
            In your <see cref="!:UpdateToVersion"/> implementation you will create a new version and copy content and
            properties from <see cref="!:IVersion"/> passed as a parameter to new version. You will also replace content and
            properties of this item. The new created version becomes current version. The <see cref="!:UpdateToVersion"/> 
            method can only be called when item is in check-in state.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="!:PutUnderVersionControl"/> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must return <b>null</b> after this call.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckInAsync">
            <summary>
            Creates new version. Copies all properties and content from this item.
            </summary>        
            <returns>
            Url of the newly created version.
            </returns>
            <remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <para>
            In your implementation you must create a new version. The content and properties of the new version must be
            copied from this item. 
            </para>
            <para>
            After the call to this method method <see cref="!:IHistory.GetCurrentVersion"/> must return the
            created version.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public string CheckIn()
{
    string newVersionUrl;
    RequireHasToken();

    if (this.VersionHistory != null)
    {
        // Create new version. Copy content and properties from this item to new version.

        Version version = this.VersionHistory.GetCurrentVersion() as Version;
        Debug.Assert(version != null);
        int newVersionNumber = version.VersionNumber + 1;
        string newVersionPath = Version.CreateVersionPath(Path, newVersionNumber);

        Guid newId = Guid.NewGuid();
        // Create new version.
        string command =
            @"INSERT INTO Version
                 (ItemId,
                  VersionId,
                  VersionNumber,
                  Name,
                  Comment,
                  CreatorDisplayName,
                  Content,
                  ContentType,
                  Created,
                  SerialNumber)
              SELECT
                  @ItemId,
                  @Identity,
                  @VersionNumber,
                  Name,
                  Comment,
                  IsNull(@CreatorDisplayName, CreatorDisplayName),
                  Content,
                  ContentType,
                  GETUTCDATE(),
                  COALESCE(SerialNumber, 1)
              FROM Item
              WHERE ItemId = @ItemId";
        // COALESCE returns the first nonnull expression among its arguments.

        Context.ExecuteNonQuery(
            command,
            "@ItemId", ItemId,
            "@VersionNumber", newVersionNumber,
            "@CreatorDisplayName",
            string.IsNullOrEmpty(CurrentUserName) ? (object)DBNull.Value : CurrentUserName,
            "@Identity", newId);

        Context.ExecuteNonQuery(
            "UPDATE Item SET Comment = '' WHERE ItemId = @ItemId",
            "@ItemId", ItemId);

        // Copy properties to new version
        string copyCommand =
            @"INSERT INTO VersionProperty( VersionId, Name, Namespace, PropVal)
              SELECT @VersionId, Name, Namespace, PropVal
              FROM Property
              WHERE ItemID = @ItemID";

        Context.ExecuteNonQuery(
            copyCommand,
            "@VersionId", newId,
            "@ItemId", ItemId);

        // Copy content to new version
        newVersionUrl = newVersionPath;
    }
    else
    {
        newVersionUrl = this.Path;
    }

    setFileCheckedOut(false, false);
    return newVersionUrl;
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.CheckOutAsync(System.Boolean)">
            <summary>
            Allow modifications to the content and properties of this version-controlled item.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <see cref="!:CheckOut"/> implementation you will mark item as checked-out and allow item
            modifications. 
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void CheckOut(bool autoCheckout)
{
    RequireHasToken();

    setFileCheckedOut(true, autoCheckout);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UnCheckOutAsync">
            <summary>
            Cancels the checkout and restores the pre-checkout state of the version-controlled item.
            </summary>
            <remarks>
            In your <see cref="!:UnCheckOut"/> implementation you will discard changes and restore pre-checkout state. 
            Content and properties must be copied from current version to this item. The item must be marked as
            checked-in.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void UnCheckOut()
{
    RequireHasToken();

    if (this.VersionHistory != null)
    {
        // Discard changes.
        // Copy content and properties from current version to this item. Mark item as checked in.
        Version version = (Version)VersionHistory.GetCurrentVersion();

        // Restore properties.
        Context.ExecuteNonQuery(
            "DELETE FROM Property WHERE ItemID = @ItemID",
            "@ItemId", ItemId);

        string command = 
             @"INSERT INTO Property(ItemId, Name, Namespace, PropVal)
               SELECT @ItemId, Name, Namespace, PropVal
               FROM VersionProperty
               WHERE VersionId = @VersionId";

        Context.ExecuteNonQuery(
            command,
            "@VersionId", version.VersionId,
            "@ItemId", ItemId);

        string updateItemCommand = 
             @"UPDATE Item
               SET Content = (SELECT Content FROM [Version] WHERE VersionId = @versionID)
               WHERE ItemId = @ItemID";

        Context.ExecuteNonQuery(
            updateItemCommand,
            "@ItemId", ItemId,
            "@VersionId", version.VersionId);
    }
    // Mark item as checked in.
    setFileCheckedOut(false, false);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.UpdateToVersionAsync(ITHit.WebDAV.Server.DeltaV.IVersionAsync)">
            <summary>
            Updates content and properties of the item to those identified by <paramref name="version"/> parameter.
            </summary>
            <remarks>
            <para>
            In your <see cref="!:UpdateToVersion"/> implementation you will create a new version and copy content and 
            properties from <see cref="!:IVersion"/> passed as a parameter to new version. You will also replace content 
            and properties of this item. The new created version becomes current version. 
            </para>
            <para>
            The <see cref="!:UpdateToVersion"/> method can only be called when item is in check-in state.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void UpdateToVersion(IVersion version)
{
    RequireHasToken();
    // Create a new version and copy content and properties from IVersion passed as a parameter. 
    // Replace content and properties of this item.
    Version ver = version as Version;
    if (ver.ItemId != this.ItemId)
    {
        throw new DavException("The version must be from the same item.", DavStatus.CONFLICT);
    }
    
    Version currVersion = this.VersionHistory.GetCurrentVersion() as Version;
    int newVersionNumber = currVersion.VersionNumber + 1;

    Guid newID = Guid.NewGuid();

    string command = 
         @"INSERT INTO Version(
               ItemId,
               VersionId,
               VersionNumber,
               Name,
               Comment,
               CreatorDisplayName,
               Content,
               ContentType,
               Created,
               SerialNumber)
           SELECT 
               @ItemId,
               @Identity,
               @VersionNumber,
               i.Name,
               i.Comment,
               i.CreatorDisplayName,
               v.Content,
               i.ContentType,
               GETUTCDATE(),
               v.SerialNumber
           FROM Item i
           INNER JOIN [Version] v ON v.ItemId = i.ItemId
           WHERE i.ItemId = @ItemId AND v.VersionId = @VersionId";

    Context.ExecuteNonQuery(
        command,
        "@ItemId", ItemId,
        "@VersionNumber", newVersionNumber,
        "@Identity", newID,
        "@VersionID", ver.VersionId);

    string updateContentCommand =
        @"UPDATE Item
          SET
              Content = v.Content,
              SerialNumber = v.SerialNumber
          FROM Item i
              INNER JOIN [Version] v ON i.ItemId = v.ItemId
          WHERE
              i.ItemId = @ItemId AND v.VersionId = @versionID";

    Context.ExecuteNonQuery(
        updateContentCommand,
        "@ItemId", ItemId,
        "@VersionId", ver.VersionId);

    // Copy properties to this item
    Context.ExecuteNonQuery(
        "DELETE FROM Property WHERE ItemID = @ItemID",
        "@ItemId", ItemId);

    string insertPropertyCommand = 
         @"INSERT INTO Property(ItemId, Name, Namespace, PropVal)
           SELECT @ItemId, Name, Namespace, PropVal
           FROM VersionProperty
           WHERE VersionId = @VersionId";

    Context.ExecuteNonQuery(
        insertPropertyCommand,
        "@ItemId", ItemId,
        "@VersionId", ver.VersionId);

    string insertVersionPropertyCommand =
        @"INSERT INTO VersionProperty(VersionId, Name, Namespace, PropVal)
          SELECT @NewVerId, Name, Namespace, PropVal
          FROM VersionProperty
          WHERE VersionId = @VersionId";

    Context.ExecuteNonQuery(
        insertVersionPropertyCommand,
        "@NewVerId", newID,
        "@VersionId", ver.VersionId);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.SetAutoVersionAsync(ITHit.WebDAV.Server.DeltaV.AutoVersion)">
            <summary>
            Sets property which determines how checked-in item responds to
            WebDAV client attempts to modify its content or properties.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>        
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion"/> enum values.</value>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void SetAutoVersion(AutoVersion value)
{
    SetDbField("AutoVersion", value);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.GetAutoVersionAsync">
            <summary>
            Retrieves property which determines how checked-in item responds to WebDAV
            client attempts to modify its content or properties.
            </summary>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion"/> enum values.</value>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public AutoVersion GetAutoVersion()
{
    return getDbField<AutoVersion>("AutoVersion", AutoVersion.NoAutoVersioning);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.PutUnderVersionControlAsync(System.Boolean)">
            <summary>
            Puts or removes current item from version control.
            </summary>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version
            control engine calls <see cref="!:PutUnderVersionControl"/> method passing <b>true</b> as a parameter.
            In your <see cref="!:PutUnderVersionControl"/> implementation you must create a new version.
            The content and properties of the new version must be copied from this item. After the call to 
            <see cref="!:PutUnderVersionControl"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must point to the object 
            implementing <see cref="!:IHistory"/> interface that will contain single version.
            The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut"/> property must return <b>false</b>;
            </para>
            <para><b>If item is under version control it mast always have at last one version in its
            versions list.</b></para>
            <para>
            If <see cref="!:DavEngine.AutoPutUnderVersionControl"/> is <b>true</b> and item is not under version control
            prior to any item content or properties update <see cref="!:IVersionableItem.PutUnderVersionControl"/>
            will be called.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="!:PutUnderVersionControl"/> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory"/> property must return <b>null</b> after this call.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public void PutUnderVersionControl(bool enable)
{
    if (enable && this.VersionHistory == null)
    {
        // Create new version. The content and properties of the new version is being copied from this item.
        SetAutoVersion(autoVersionMode);

        Guid newID = Guid.NewGuid();
        string insertVersionCommand =
            @"INSERT INTO Version(
                  ItemId,
                  VersionId,
                  VersionNumber,
                  Name,
                  Comment,
                  CreatorDisplayName,
                  Content,
                  ContentType,
                  Created,
                  SerialNumber)
               SELECT
                  @ItemId,
                  @Identity,
                  1,
                  Name,
                  Comment,
                  @CreatorDisplayName,
                  Content,
                  ContentType,
                  GETUTCDATE(),
                  0
                FROM Item
                WHERE ItemId = @ItemId";

        Context.ExecuteNonQuery(
            insertVersionCommand,
            "@ItemId", ItemId,
            "@CreatorDisplayName", CurrentUserName,
            "@Identity", newID);

        string insertVersionPropertyCommand =
            @"INSERT INTO VersionProperty(VersionId, Name, Namespace, PropVal)
              SELECT @VersionId, Name, Namespace, PropVal
              FROM Property
              WHERE ItemID = @ItemId";

        Context.ExecuteNonQuery(
            insertVersionPropertyCommand,
            "@VersionId", newID,
            "@ItemId", ItemId);

        setFileCheckedOut(false, false);
    }
    else if (!enable)
    {
        // Delete all versions
        Context.ExecuteNonQuery(
            "DELETE FROM Version WHERE ItemId = @ItemId",
            "@ItemId", ItemId);
    }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.VersionHistory">
            <summary>
            Current item version history. Null, if item is not under version control.
            </summary>
            <value>
            Item implementing <see cref="!:IHistory"/> interface or null if item is not under version control.
            </value>
            <remarks>If item is under version control it always has at last
            one version in its versions list. This property is used for precondition checking and shall not throw
            exceptions.
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public IHistory VersionHistory
{
    get
    {
        string command =
            @"SELECT VersionId
              FROM Version
              WHERE ItemId = @ItemId";

        if (Context.ExecuteScalar<object>(command, "@ItemId", ItemId) != null)
        {
            return new VersionHistory(Context, ItemId, Path + "?history");
        }

        return null;
    }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsCheckedOut">
            <summary>
            Gets a value indicating whether the item is in checked-in or checked-out state.
            </summary>
            <value>
            Boolean value indicating if item is in checked-out state.
            </value>
            <remarks>
            This property is used for precondition checking and shall not throw exceptions.
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public bool IsCheckedOut
{
    get { return getDbField("CheckedOut", false); }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItemAsync.IsAutoCheckedOut">
            <summary>
            Gets a value indicating whether the item was check-out automatically by engine without
            explicit request from client.
            </summary>
            <remarks>
            Before checking-out the engine sets this property.
            When item is being unlocked engine reads this property and calls 
            <see cref="!:IVersionableItem.CheckIn"/> if necessary. This property is required for auto-versioning.
            This property shall not throw exceptions.
            </remarks>
            <example>
      <para>The code below is part of 'DeltaV' sample provided with the SDK.</para>
      <code><![CDATA[public bool IsAutoCheckedOut
{
    get { return getDbField("AutoCheckedOut", false); }
    set { SetDbField("AutoCheckedOut", value); }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEngineAsync">
            <summary>
            The DavEngine class provides the core implementation for WebDAV engine.
            </summary>
            <remarks>
            <para>Engine parses XML send by WebDAV client, processes requests making calls to your implementations of 
            WebDAV interfaces (<see cref="!:IHierarchyItem"/>, <see cref="!:IFolder"/>, <see cref="!:IFile"/> and other) 
            and finally generates XML response.
            </para>
            <para>
            In each HTTP request you will create separate instance of your class derived 
            from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class and pass it to the <see cref="!:DavEngine.Run"/> method. Via the context, engine 
            receives all necessary information about hosting environment.
            </para>     
            <para>
            You must set <see cref="P:ITHit.WebDAV.Server.DavEngineAsync.License"/> property before you can use the engine.
            </para>
            <para>
            All updates invoked within one request execution shall be inside one transactions.
            Transaction can be committed or rollbacked in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> method, which
            is called right before starting sending response to client.
            After this method is called, no methods of interfaces which update state will be called. However methods
            which read state can be called.
            </para>
            </remarks>
            <threadsafety>Method <see cref="!:Run"/> is threadsafe. All other members are not threadsafe.
            You can create a single instance of DavEngine, initialize it onces and use to serve all requests 
            from different threads.</threadsafety>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public bool IsReusable
    {
        get { return true; }
    }

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngine engine = getOrInitializeEngine(context);

        context.Response.BufferOutput = false;
        DavContext ntfsDavContext = new DavContext(context);
        await engine.Run(ntfsDavContext);
    }

    private DavEngine initializeEngine(HttpContext context)
    {

        var engine = new DavEngine
        {
            Logger = Logger.Instance
            //Use idented responses if debug logging is enabled.
            ,OutputXmlFormatting = debugLoggingEnabled ? Formatting.Indented : Formatting.None
        };
        engine.License = File.ReadAllText(context.Request.PhysicalApplicationPath + "License.lic");

        return engine;
    }

    private DavEngine getOrInitializeEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeEngine(context);
        }

        return (DavEngine)context.Application[ENGINE_KEY];
    }
}
]]></code>
    </example>
            <example>
            <para>HttpListener-based server:</para>
            <code>
            class Program
            {
                static void Main(string[] args)
                {
                    HttpListener listener = new HttpListener();
                    listener.Prefixes.Add("http://localhost:8080/");
                    listener.Start();
                    DavEngine engine = new DavEngine();
                    engine.License = "..."; 
                    while (true)
                    {
                        HttpListenerContext context = listener.GetContext();
                        engine.Run(new MyContext(context, listener.Prefixes));
                        try
                        {
                            context.Response.Close();
                        }
                        catch
                        {
                            // client closed connection before the content was sent
                        }
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.#ctor">
            <summary>
            Initializes a new instance of the DavEngine class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.Extensibility.IMethodHandlerAsync)">
            <summary>
            Registers custom method handler.
            </summary>
            <param name="method">HTTP verb.</param>
            <param name="handler">Custom handled implementing <see cref="!:IMethodHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom method handler to be called by the engine.
            If the handler for the specified method was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
            <example>
            <code>
            <![CDATA[
               DavEngine engine = new DavEngine();
               MyCustomGetHandler handler = new MyCustomGetHandler();
               handler.OriginalHandler = engine.RegisterMethodHandler("GET", handler);
            
               MyDavContext context = new MyDavContext(...);
               engine.Run(context);
            ]]>
            </code>
            </example>
            <example>
      <para>The code below is part of 'CalDav' sample provided with the SDK.</para>
      <code><![CDATA[internal class MyCustomGetHandler : IMethodHandler
{
    public IMethodHandler OriginalHandler { get; set; }

    public bool EnableOutputBuffering
    {
        get { return false; }
    }

    public bool EnableOutputDebugLogging
    {
        get { return false; }
    }

    public bool EnableInputDebugLogging
    {
        get { return false; }
    }

    public async Task ProcessRequest(DavContextBase context, IHierarchyItem item)
    {
        if (item is IFolder)
        {
            // In case of GET requests to WebDAV folders we serve a web page to display 
            // any information about this server and how to use it.

            // Remember to call EnsureBeforeResponseWasCalled here if your context implementation
            // makes some useful things in BeforeResponse.
            context.EnsureBeforeResponseWasCalled();
            IHttpAsyncHandler page = (IHttpAsyncHandler)System.Web.Compilation.BuildManager.CreateInstanceFromVirtualPath(
                "~/MyCustomHandlerPage.aspx", typeof(MyCustomHandlerPage));

            // here we call BeginProcessRequest instead of ProcessRequest to start an async page execution and be able to call RegisterAsyncTask if required.
            page.BeginProcessRequest(HttpContext.Current, null, null);
        }
        else
        {
            OriginalHandler.ProcessRequest(context, item);
        }
    }
    
    public bool AppliesTo(IHierarchyItem item)
    {
        return item is IFolder || OriginalHandler.AppliesTo(item);
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterPropertyHandler(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.Extensibility.IPropertyHandlerAsync)">
            <summary>
            Registers custom property handler.
            </summary>
            <param name="propName">Property name.</param>
            <param name="handler">Custom handled implementing <see cref="!:IPropertyHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Property handler allows formatting of property values to XML and reading property values from XML.
            Using this method you can register custom property handler to be called by the engine.
            If the handler for the specified property was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterOptionsHandler(System.String,ITHit.WebDAV.Server.Extensibility.IOptionsHandler)">
            <summary>
            Registers custom options handler.
            </summary>
            <param name="name">Token that will be added to 'DAV' header for OPTIONS response.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom options handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RegisterReportHandler(System.String,System.String,ITHit.WebDAV.Server.Extensibility.IReportHandlerAsync)">
            <summary>
            Registers custom report handler.
            </summary>
            <param name="name">Report element name.</param>
            <param name="namespace">Report namespace.</param>
            <param name="handler">Custom handled implementing <see cref="!:IReportHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom report handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.RunAsync(ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Processes WebDAV request and generates WebDAV response.
            </summary>
            <param name="context">
            Instance of your context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.
            </param>
            <remarks>
            <para>
            You must call Run method in each request to your WebDAV server passing your 
            context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> as input parameter. 
            </para>
            </remarks>
            <example>
            <code>
            DavEngine engine = new DavEngine();
            engine.License = "...";
            ...
            MyContext context = new MyContext(HttpContext.Current);
            engine.Run(context);
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngineAsync.ProcessWellKnownRequest(ITHit.WebDAV.Server.IHierarchyItemAsync,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Sets 301 Moved Permanently in case of requests to '/.well-known/caldav' 
            or '/.well-known/carddav' url.
            </summary>
            <remarks>
            Gives a chance fot the user to return hierarchy item that coresponds to 
            well-known requests to CalDAV and CardDAV servers.
            </remarks>
            <returns>Boolean value indicating if this is a well known request.</returns>
            <remarks>
            http://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml
            http://tools.ietf.org/html/rfc5785
            http://tools.ietf.org/html/rfc6764
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.License">
            <summary>
            Gets or sets the license text.
            </summary>
            <value>
            License string
            </value>
            <remarks>
            Make sure you do not make any changes in Data and Signature tags as 
            license validation will fail in this case.
            </remarks>
            <example>
            <code>
                ...
                engine.License = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
                ...
            </code>
            </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.CalculateContentLength">
            <summary>
            Indicates if response content length calculation will occur.
            </summary>
            <value>
            Boolean value indicating if content length will be calculated in <see cref="!:Run"/> method.
            Default is <b>true</b>.
            </value>
            <remarks>
            <para>
            If this property is set to <b>true</b> engine will calculate output content length and set 
            <see cref="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentLength"/> property before returning from <see cref="!:Run"/> method.
            If you would like to send chunked responses you must set this property to <b>false</b>.
            </para>
            <para>
            ASP.NET will send chunked responses only to <b>GET</b> verb if 
            <b>HttpContext.Current.Response.BufferOutput = false</b> and request is HTTP 1.1. Responses to all
            other verbs will not be chunked.
            </para>
            <para>
            To send chunked responses from <b>HttpListener</b> you must set this property to false and set 
            <b>HttpListenerContext.Response.SendChunked = true</b>. If <b>SendChunked=false</b> and 
            <b>CalculateContentLength=false</b> than <b>HttpListener</b> will not send any response because the 
            content length will be unknown.
            </para>
            <para>
            Responses must not include both <b>Content-Length</b> header and <b>Transfer-Encoding: chunked</b> 
            header. If server is sending chunked response client application will not be able to detect content length.
            Downloading a large file using download manager client will not be able to see the entire content length 
            and evaluate time required for download.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.CorsAllowedFor">
            <summary>
            Enables or disables CORS.
            </summary>
            <remarks>
            <para>
            If this property is set to <b>*</b> CORS will be enabled for in all domains. In this case, if the <b>Origin</b> request header is available
            the Engine will extract the value of the <b>Origin</b> header and set the <b>Access-Control-Allow-Origin</b> header to the value of the <b>Origin</b> header. 
            If <b>Origin</b> header is not available the <b>Access-Control-Allow-Origin</b> header will be set to '*'.
            </para>
            <para>
            To enable CORS for a specific domain set this property to the name of the of the domain.
            To disable CORS set this property to <b>null</b> or empty string.
            </para>
            <para>
            If CORS is enabled Access-Control headers are included in all responses.
            </para>
            </remarks>
            <value>Domain for which CORS is enabled. Null or empty string if CORS is disabled. Default is <b>*</b> - CORS is enabled for all domains.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.AutoPutUnderVersionControl">
            <summary>
            Determines if placing file under version control is automatic.
            </summary>
            <remarks>
            <value>Boolean value indicating if items must be put under version control before content or properties
            update. Default is <b>true</b>.</value>
            <para>
            Determines whether items will be placed under version control automatically
            or explicit request from client shall be made to put an item under version control.
            </para>
            <para>
            If this property is <c>true</c> the <see cref="!:IVersionableItem.PutUnderVersionControl"/> will be called 
            after item is created and prior item content or properties update.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.ContentEncoding">
            <summary>
            Gets or sets the HTTP character set of the output stream.
            </summary>
            <value>A <c>Encoding</c> object that contains information about the character set of the response.
            Default is UTF-8.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.UseFullUris">
            <summary>
            Specifies whether engine shall use full or relative urls.
            </summary>
            <remarks>
            By default full urls are used.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.Logger">
            <summary>
            <see cref="T:ITHit.WebDAV.Server.ILogger"/> instance which engine will use for logging.
            </summary>
            <remarks>
            By default this is <see cref="T:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.OutputXmlFormatting">
            <summary>
            Specifies whether XML written to the output will be formatted.
            </summary>
            <remarks>
            By default XML is not formatted.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngineAsync.AllowOffice12Versioning">
            <exclude />
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.FileLogger">
            <summary>
            Provides static methods for writing to a log file.
            </summary>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. You can specify the folder and file name setting <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile"/> property. 
            Amount of output and maximum file size are controlled via <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.Level"/> and <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize"/> properties.
            </para>
            <para>
            <b>Important!</b> If you host your server in IIS/ASP.NET make sure your log file is created outside of the \bin folder. If your logfile will be created in a \bin folder, your server will restart each time the logfile is updated, recycling application and session state.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String)">
            <summary>
            Wrights a message to a log file with level <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Info"/>.
            </summary>
            <param name="message">Message to be logged.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String,ITHit.WebDAV.Server.Logger.LogLevel)">
            <summary>
            Wrights a message to a log file with a specified log level.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="level">Logging level.</param>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile">
            <summary>
            Gets and sets log file name and path.
            </summary>
            <value>
            Log file name and path.
            </value>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. The folder in which you plan store your log files must exist and 
            your web application must have enough permission for writing and creating 
            files in this folder. Note that if you are creating HttpHandler-based server usually on Windows XP your web application 
            runs under ASPNET account while on Windows 2003 it runs under Network Service account.
            </para>
            <para>
            If you are requesting your server with a WebDAV client and log file is not 
            created, most likely there is no permissions for creating file or the web 
            requests simply does not reach your application.
            </para>
            <code>
            public class WebDAVHandler : IHttpHandler
            {
            	public void ProcessRequest(HttpContext context)
            	{
            		FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";
            		...
            	}
            	...
            }
            </code>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.Level">
            <summary>
            Gets and sets how much information is written to log file.
            </summary>
            <value>Logging level. Default is <c>Info</c></value>
            <remarks>
            Provides the method of limiting amount of logging output. During the 
            development you will usually set <c>LogLevel</c> to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.All"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug"/> level, while 
            deploying you can set it to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Error"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize">
            <summary>
            Gets and sets maximum log file size in bytes.
            </summary>
            <value>
            Maximum log file size in bytes. Default is 1048576 bytes.
            </value>
            <remarks>
            When the file exceeds the size specified by <c>FileSize</c> the new log file is created. The old file is renamed to &lt;filename&gt;.&lt;number&gt;.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.MaxBackups">
            <summary>
            Gets and sets Maximum number of log file backups.
            </summary>
            <value>
            Amount of log file backups. Default is 1.
            </value>
            <remarks>
            If the amount of the backup files created is higher than <c>MaxBackups</c> the oldest file is automatically deleted.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamInput">
            <summary>
            Logs input content
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamOutput">
            <summary>
            Calculates content length ang logs output content
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CopyDavHandler">
            <summary>
            Summary description for CopyDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.DeleteDavHandler">
            <summary>
            Summary description for DeleteDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.GetDavHandler">
            <summary>
            Summary description for GetDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.HeadDavHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.LockDavHandler">
            <summary>
            Summary description for LockDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcolDavHandler">
            <summary>
            Summary description for MkcolDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MoveDavHandler">
            <summary>
            Summary description for MoveDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PostDavHandler">
            <summary>
            Summary description for PostDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PropfindDavHandler">
            <summary>
            Summary description for PropfindDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.ProppatchDavHandler">
            <summary>
            Summary description for ProppatchDavHandler
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.UnlockDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync">
            <summary>
            Implemented by a file that supports updating parts of its content.
            </summary>
            <remarks>
            <para>
            You will implement this interface together with <see cref="!:IUploadProgress"/> interface when you would like to
            provide one or more of the following features:
            <list type="bullet">
            <item><description>Pause/resume uploads.</description></item>
            <item><description>Restore broken uploads.</description></item>
            <item><description>Upload from AJAX using POST verb and create upload progress bars. Required in IE 9 and earlier only.</description></item>
            <item><description>Upload to ASP.NET/IIS-based server files over 2Gb.</description></item>
            </list>
            </para>
            <para>The WebDAV Server Engine can process two types of upload requests:
            <list type="bullet">
            <item><description> <b>PUT upload.</b> Files uploaded via PUT by most WebDAV compliant clients.</description></item>
            <item><description> <b>POST upload.</b> Files uploaded via POST verb by Ajax applications running in Microsoft Internet Explorer 9 and earlier. </description></item>
            </list>
            </para>
            <para>To provide information about what segment of a file is being uploaded, the client application will
            attach optional <c>Content-Range: bytes XXX-XXX/XXX</c> header to PUT request. </para>
            <para>Internet Explorer 9 and earlier limitations is unable to randomly read
            file content and upload content using PUT verb. To overcome this limitation the Engine can process files
            uploaded using POST verb. 
            Internet Explorer 9 and earlier still can display upload progress submitting upload-progress REPORT request
            (see <see cref="!:IUploadProgress"/> interface description for more info). </para>
            </remarks>
            <example>The following example demonstrates upload to WebDAV server using POST with multipart encoding.
            The file will be created in /mydocs/ folder.
            <code>
            <![CDATA[
            <html>
                <head><title>POST Upload to WebDAV Server</title></head>
                <body>
                    <form action="/mydocs/" method="post" enctype="multipart/form-data">
                        <input type="file" name="dummyname" /><br />
                        <input type="submit" />
                    </form>
                </body>
            </html>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.CancelUploadAsync">
            <summary>
            In this method implementation you can delete partially uploaded file.
            </summary>    
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            Often during long-continued upload you will keep the old file 
            content to be returned by GET requests and store the new file content in a
            temporary file (or temporary field in database, etc).  To delete this partially
            uploaded content client can submit CANCELUPLOAD command, the Engine will call this method in this case.
            </para>
            <para>If the item was automatically checked-out by the Engine when upload started it will be automatically
            checked-in by the Engine after this call.</para>
            </remarks>
            <example>
            Request:
            <code>
            <![CDATA[
            CANCELUPLOAD /LargeFile.doc HTTP/1.1
            Host: http://server:8580/
            ]]>
            </code>
            
            Response:
            <code>
            <![CDATA[
            HTTP/1.1 200 OK
            ]]>
            </code>
            </example>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.CancelUpload&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.LastChunkSaved">
            <summary>
            The date and time when the last chunk of file was saved in your storage.
            </summary>
            <remarks>
            <para>Requested by the Engine during a call to 
            <see cref="!:IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.LastChunkSaved&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.BytesUploaded">
            <summary>
            Amount of bytes successfully saved to your storage.
            </summary>
            <remarks>
            <para>Client will use value returned by this property to restore broken upload.
            This value shall always reflect number of bytes already stored to persistent medium.
            </para>
            <para>Requested by the Engine during a call to 
            <see cref="!:IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.BytesUploaded&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUploadAsync.TotalContentLength">
            <summary>Total file size that is being uploaded.</summary>
            <remarks>
            <para>This value is passed to <see cref="!:IContent.Write"/> method.
             Usually AJAX/HTML based clients will use value returned by this property to display upload progress.</para>
            <para>Requested by the Engine during a call to <see cref="!:IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <returns>Total file size in bytes.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.TotalContentLength&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.ILockAsync">
            <summary>
            Defines the properties and methods that WebDAV Class 2 compliant server hierarchy items must implement.
            </summary>
            <remarks>
            <para>
            This interface provides the means for locking the hierarchy item, updating lock timeout and accessing the 
            list of applied locks. To create WebDAV Class 2 compliant server you must implement this interface on 
            your file and folder items.
            </para>
            <para>
            When this interface is implemented on an item the server reports Class 2 compliance, returning DAV: 1, 2, 3 
            header in response to the OPTIONS request. Note that while most WebDAV clients never lock folder items, 
            you must still add this interface on folders, as soon as WebDAV clients submit OPTIONS request against folder 
            items when discovering server compliance.
            </para>
            <para>
            When a WebDAV client requires to protect an item from concurrent updates, it locks the item (usually file), 
            submitting lock request to server. The server generates the new lock-token, marks the item as locked and returns 
            the new lock-token to the client. The WebDAV client application keeps the lock-token and when it requires to 
            perform any updates, it supplies the lock-token with the request. When the server receives the update request, 
            it verifies that the lock token belongs to the item that is being updated and performs modifications.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.GetActiveLocksAsync">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEnumerable`1"/> with all locks for this item.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            This property must return all locks for the item including deep locks on any of the parent folders.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public IEnumerable<LockInfo> GetActiveLocks()
{
    return getExplicitLocks().Select(
            l => new LockInfo
                 {
                     IsDeep = l.IsDeep,
                     Level = l.Level,
                     Owner = l.ClientOwner,
                     LockRoot = l.LockRoot,
                     TimeOut = l.Expiration == DateTime.MaxValue ?
                        TimeSpan.MaxValue :
                        l.Expiration - DateTime.UtcNow,
                     Token = l.LockToken
                 });
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.LockAsync(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Locks this item.
            </summary>
            <param name="level">Whether lock is shared or exclusive. If an exclusive lock is set other users are not 
            be able to set any locks. If a shared lock is set other users are able to set shared lock on the item.</param>
            <param name="isDeep">Specifies if the lock applied only to this item or to the entire subtree.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client. Some clients may not provide any timeout. The <b>null</b> is passed in this case.</param>
            <param name="owner">Owner of the lock as specified by client.</param> 
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.LockResult"/> that contains lock-token and timeout that was actually set.
            </returns>
            <remarks>
            This method is called when item is being locked by WebDAV client. In your implementation you must do the following:
            <list type="number">
            <item><description>Generate the new lock-token, usually GUID.</description></item>
            <item><description>Save information about the lock in a storage.</description></item>
            <item><description>Associate the lock with the item in the repository.</description></item>
            <item><description>Return the lock-token to the Engine.</description></item>
            </list>
            Optionally in in this method you can modify the lock timeout requested by client. For example instead of infinity 
            lock you can set lock for some limited time. You must return both lock-token and lock timeout via <see cref="T:ITHit.WebDAV.Server.Class2.LockResult"/> 
            return value, the engine than sends the lock-token and timeout values back to WebDAV client.
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[
public LockResult Lock(LockLevel level, bool isDeep, TimeSpan? requestedTimeOut, string owner)
{
    RequireUnlocked(level == LockLevel.Shared);

    string token = Guid.NewGuid().ToString();

    TimeSpan timeOut;
    if (!requestedTimeOut.HasValue || requestedTimeOut == TimeSpan.MaxValue)
    {
        // If timeout is absent or infinit timeout requested,
        // grant 5 minute lock.
        timeOut = TimeSpan.FromMinutes(5);
    }
    else
    {
        timeOut = requestedTimeOut.Value;
    }

    DateTime expiration = DateTime.UtcNow + timeOut;

    explicitLocks.Add(new DateLockInfo
                          {
                              Expiration = expiration,
                              IsDeep = false,
                              Level = level,
                              LockRoot = Path,
                              LockToken = token,
                              ClientOwner = owner,
                              TimeOut = timeOut
                          });
    saveLocks();

    return new LockResult(token, timeOut);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.RefreshLockAsync(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Updates lock timeout information on this item.
            </summary>
            <param name="token">Lock token.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.RefreshLockResult"/> that contains information about the lock including timeout that was actually set.
            </returns>
            <remarks>This method is called when WebDAV client wants to modify (usually prolong) timeout for the previously 
            set lock. In this method implementation you can update the lock timeout. Note that you can ignore the requested 
            timout and set timeout that is different from the one requested by client.</remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public RefreshLockResult RefreshLock(string token, TimeSpan? requestedTimeOut)
{
    DateLockInfo li = getExplicitLocks().SingleOrDefault(l => l.LockToken == token);

    if (li == null)
    {
        throw new DavException("Lock can not be found.", DavStatus.PRECONDITION_FAILED);
    }

    if (requestedTimeOut.HasValue && requestedTimeOut != TimeSpan.MaxValue)
    {
        // Update timeout if it is specified and not Infinity.
        // Otherwise leave previous timeout.
        li.TimeOut = requestedTimeOut.Value;
    }

    if (!requestedTimeOut.HasValue)
        li.TimeOut = TimeSpan.FromMinutes(5);

    li.Expiration = DateTime.UtcNow + li.TimeOut;

    saveLocks();

    return new RefreshLockResult(li.Level, li.IsDeep, li.TimeOut, li.ClientOwner);
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILockAsync.UnlockAsync(System.String)">
            <summary>
            Removes lock with the specified token from this item.
            </summary>
            <param name="lockToken">Lock with this token should be removed from the item.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            If this lock included more than one hierarchy item, the lock is removed from all items included in the lock.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public void Unlock(string lockToken)
{
    int i = getExplicitLocks().FindIndex(li => li.LockToken == lockToken);
    if (i >= 0)
    {
        getExplicitLocks().RemoveAt(i);
    }
    else
    {
        throw new DavException("The lock could not be found.", DavStatus.PRECONDITION_FAILED);
    }

    saveLocks();
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseChecker">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CheckLicense(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.AddBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.DivideBigIntegers(System.Int64[],System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.MultiplyBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.SubtractBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.UnaryNegationBigInteger(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.LessThanOrEqualBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.ModulusBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CryptographyTest">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockInfo">
            <summary>
            Serves for exchanging locking information with WebDAV engine.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.String,System.Nullable{System.TimeSpan},System.String,System.String)">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
            <param name="level">Shared or exclusive.</param>
            <param name="isDeep">Whether the lock is deep.</param>
            <param name="token">Lock token.</param>
            <param name="timeOut">Lock timeout.</param>
            <param name="owner">Lock owner.</param>
            <param name="lockRoot">Parent item on which this lock is specified explicitely.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Token">
            <summary>
            The lock token associated with a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Level">
            <summary>
            Indicates whether a lock is shared or exclusive.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.TimeOut">
            <summary>
            Lock expiration time.
            </summary>
            <remarks>
            Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> means infinity
            lock that never expires. The <b>null</b> value means that timeout was not provided by a client.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Owner">
            <summary>
            Provides information about the principal taking out a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.LockRoot">
            <summary>
            Parent item on which this lock is specified explicitely.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.LogLevel">
            <summary>
            Type of information being logged.
            </summary>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.All">
            <summary>
            All messages will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug">
            <summary>
            Messages with <c>LogLevel.Debug</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Info">
            <summary>
            Messages with <c>LogLevel.Info</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Warn">
            <summary>
            Messages with <c>LogLevel.Warn</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Error">
            <summary>
            Messages with <c>LogLevel.Error</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal">
            <summary>
            Messages with <c>LogLevel.Fatal</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Off">
            <summary>
            No messages will be written to log.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MimeType">
             <summary>
             Provides functionality for getting mime type by file extension.
             </summary>
             <remarks>
             <para>
             The <see cref="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)"/> static method of this class returns mime type by provided file extension. 
             The class is usually utilized in <see cref="!:IContent.ContentType"/> implementation. The mime-type is returned in
             a Content-Type header with GET request.
             The set of values can be extended with using <see cref="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)"/> method.
             </para>
             <para>
             When deciding which action to perform when downloading a file some WebDAV clients and browsers
             (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type header
             returned by server. For identical behavior in all browsers and WebDAV clients your server must return a correct
             mime-type with a requested file.
             </para>
             </remarks>
             <example>
             <code>
             public string ContentType
             {
                 get
                 {
                     string contentType = "";
            
                     SqlConnection conn = new SqlConnection(connStr);
                     SqlCommand cmd;
                     SqlDataReader reader = null;
                     conn.Open();
            
                     try
                     {
                         cmd = conn.CreateCommand();
                         cmd.CommandText = "SELECT ContentType FROM Repository WHERE ID = @ID";
                         cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
                         reader = cmd.ExecuteReader();
                         reader.Read();
                         if(!reader.IsDBNull(reader.GetOrdinal("ContentType")))
                             contentType = reader.GetString(reader.GetOrdinal("ContentType"));
                     }
                     finally
                     {
                         if(reader != null) reader.Close();
                             conn.Close();
                     }
            
                     if (string.IsNullOrEmpty(contentType))
                         contentType = 
                             MimeType.GetMimeType(System.IO.Path.GetExtension(this.fName))
                             ?? "application/octet-stream";
                     return contentType;
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)">
            <summary>
            Extends the list of content types or replaces existing value with a new one.
            </summary>
            <param name="extension">File extension.</param>
            <param name="mimeType">File mime type.</param>
            <example>
            <code>
            MimeType.ExtendTypesTable("exten", "application/exten");
            Console.WriteLine(MimeType.GetMimeType("exten"));
            </code>
            Writes: <c>"application/exten"</c>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)">
            <summary>
            Returns the mime type corresponding to file extension.
            </summary>
            <param name="extension">File extension.</param>
            <returns>String representing mime-type or null if mime-type was not found for the specified extension.
            </returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyValue">
            <summary>
            Describes one property associated with hierarchy item object.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.Value">
            <summary>
            The value of the property.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.QualifiedName">
            <summary>
            Name of the property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.ListenerRequest">
            <summary>
            Represents an incoming HTTP request for HttpListener.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.ListenerResponse">
            <summary>
            Represents HTTP response for HttpListener.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Extensibility.ListenerResponse.response">
            <summary>
            The http response response.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Extensibility.ListenerResponse.outputStream">
            <summary>
            The output stream.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.ListenerResponse.#ctor(System.Net.HttpListenerResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Extensibility.ListenerResponse"/> class.
            </summary>
            <param name="response">The response.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav.PropertyNames">
            <summary>
            WebDAV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.SearchOptions">
            <summary>
            Represents DASL search parameters.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchContent">
            <summary>
            Gets/sets value indicating the search in file content.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchName">
            <summary>
            Gets/sets value indicating the search in file name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.MatchBy">
            <summary>
            Is used by <see cref="!:IAclHierarchyItem.GetItemsByProperty"/> to identify by which
            property items shall be retrieved.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Group">
            <summary>
            This value is used to indicate that items whose Group contains currently
            logged in principal shall be returned.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Owner">
            <summary>
            This value is used to indicate that items whose Owner corresponds
            to or contains currently logged in principal shall be returned.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockedException">
            <summary>
            This exception shall be thrown in cases when item is locked and client didn't provide lock token or if the item is already locked.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Context.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavStatus">
            <summary>
            Represents HTTP status code with description.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.OK">
            <summary>
            Successful result.
            </summary>  
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNAUTHORIZED">
            <summary>
            The request requires user authentication.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CONFLICT">
            <summary>
            The request could not be completed due to a conflict with the current state of the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CREATED">
            <summary>
            The request has been fulfilled and resulted in a new resource being created.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY">
            <summary>
            This status code means that the method could
            not be performed on the resource because the requested action
            depended on another action and that action failed.  For example, if a
            command in a PROPPATCH method fails, then, at minimum, the rest of
            the commands will also fail with 424 (Failed Dependency).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.LOCKED">
            <summary>
            This status code means the source or destination resource
            of a method is locked.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NO_CONTENT">
            <summary>
            The server has fulfilled the request but does not need to return an entity-body, and might want to return
            updated metainformation.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED">
            <summary>
            The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED">
            <summary>
            The precondition given in one or more of the request-header fields evaluated to false when it was tested on
            the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INTERNAL_ERROR">
            <summary>
            The server encountered an unexpected condition which prevented it from fulfilling the request. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.BAD_REQUEST">
            <summary>
            The request could not be understood by the server due to malformed syntax.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MULTISTATUS">
            <summary>
            The 207 (Multi-Status) status code provides status for multiple
            independent operations.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_FOUND">
            <summary>
            The server has not found anything matching the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_MODIFIED">
            <summary>
            If the client has performed a conditional GET request and access is allowed, but the document has not been
            modified, the server SHOULD respond with this status code.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PARTIAL_CONTENT">
            <summary>
            The server has fulfilled the partial GET request for the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FORBIDDEN">
            <summary>
            The server understood the request, but is refusing to fulfill it.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_IMPLEMENTED">
            <summary>
            The server does not support the functionality required to fulfill the request. This is the appropriate 
            response when the server does not recognize the request method and is not capable of supporting it for any
            resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNSUPPORTED_MEDIA_TYPE">
            <summary>
            The server is refusing to service the request because the entity of the request is in a format not
            supported by the requested resource for the requested method. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MOVED_PERMANENTLY">
            <summary>
            The requested resource resides permanently under a different URI.
            </summary>
            <remarks>The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.</remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FOUND">
            <summary>
            The requested resource resides temporarily under a different URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INSUFFICIENT_STORAGE">
            <summary>
            The 507 (Insufficient Storage) status code means the method could not
            be performed on the resource because the server is unable to store
            the representation needed to successfully complete the request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the DavStatus struct.
            </summary>
            <param name="code">HTTP status code.</param>
            <param name="description">Status description.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Equality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Inequality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Code">
            <summary>
            HTTP status code.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Description">
            <summary>
            Status description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.HttpString">
            <summary>
            Formats status as HTTP string.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.EncodeUtil">
            <summary>
            Encodes/Decodes url parts.
            </summary>
            <remarks>
            This class shall be used to encode/decode parts of urls. Unlike <see cref="T:System.Web.HttpUtility"/> class provided with .Net, this class encodes ' '(space) as %2b.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.EncodeUrlPart(System.String)">
            <summary>
            Encodes url part.
            </summary>
            <param name="part">Url part to encode.</param>
            <returns>Encoded url part.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.DecodeUrlPart(System.String)">
            <summary>
            Decodes url part.
            </summary>
            <param name="part">Url part to decode.</param>
            <returns>Decoded url part.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.ErrorDetails">
            <summary>
            Describes detail that can be passed to <see cref="T:ITHit.WebDAV.Server.DavException"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_IN">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-in property
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-out property
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_HISTORY">
            <summary>
            If the request-URL identifies a version history, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_COPY_HISTORY">
            <summary>
            If the request-URL identifies a version
            history, the request MUST fail. In order to create another
            version history whose versions have the same content and dead
            properties, the appropriate sequence of VERSION-CONTROL, CHECKOUT,
            PUT, PROPPATCH, and CHECKIN requests must be made
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT_VERSION_CONTROLLED_RESOURCE">
            <summary>
            The request-URL MUST identify a version-controlled resource with a DAV:checked-out property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.VERSION_HISTORY_IS_TREE">
            <summary>
            If the request-URL identifies a
            checked-out version-controlled resource that will be automatically
            checked in when the lock is removed, then the versions identified
            by the DAV:predecessor-set of the checked-out resource MUST be
            descendants of the root version of the version history for the
            DAV:checked-out version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_CONTENT">
            <summary>
            If the request-URL
            identifies a resource with a DAV:checked-in property, the request
            MUST fail unless DAV:auto-version semantics will automatically
            check out the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_PROPERTY">
            <summary>
            If the request attempts to modify a dead property, same semantics as PUT
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_LIVE_PROPERTY">
            <summary>
            If the request attempts to access a
            property defined by this document, the semantics of that property
            MUST be supported by the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_VERSION_DELETE">
            <summary>
            A server MAY fail an attempt to DELETE a version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_REPORT">
            <summary>
            The specified report MUST be supported by
            the resource identified by the request-URL.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_PROTECTED_PROPERTY">
            <summary>
            The client attempted to set a protected property in a PROPPATCH (such as DAV:getetag).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PROPFIND_FINITE_DEPTH">
            <summary>
            This server does not allow infinite-depth PROPFIND requests on collections.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PRESERVED_LIVE_PROPERTIES">
            <summary>
            The server received an otherwise-valid MOVE or COPY request, but
            cannot maintain the live properties with the same behavior at the destination. It may be that
            the server only supports some live properties in some parts of the repository, or simply has an
            internal error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_CONFLICTING_LOCK">
            <summary>
            A LOCK request failed due the presence of an already existing conflicting lock. Note that a
            lock can be in conflict although the resource to which the request was directed is only
            indirectly locked. In this case, the precondition code can be used to inform the client about
            the resource that is the root of the conflicting lock, avoiding a separate lookup of the
            "lockdiscovery" property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_SUBMITTED">
            <summary>
            The request could not succeed because a lock token should have been submitted. This
            element, if present, MUST contain at least one URL of a locked resource that prevented the
            request. In cases of MOVE, COPY, and DELETE where collection locks are involved, it can
            be difficult for the client to find out which locked resource made the request fail -- but the
            server is only responsible for returning one such locked resource. The server MAY return
            every locked resource that prevented the request from succeeding if it knows them all.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_MATCHES_REQUEST_URI">
            <summary>
            A request may include a Lock-Token header to identify a lock for the
            UNLOCK method. However, if the Request-URI does not fall within the scope of the lock
            identified by the token, the server SHOULD use this error. The lock may have a scope that
            does not include the Request-URI, or the lock could have disappeared, or the token may be
            invalid.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_EXTERNAL_ENTITIES">
            <summary>
            If the server rejects a client request because the request body contains an
            external entity, the server SHOULD use this error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS">
            <summary>
            The number of matching principals must fall within
            server-specific, predefined limits. For example, this condition might be triggered if a search specification
            would cause the return of an extremely large number of responses.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the ErrorDetails struct.
            </summary>
            <param name="namespace">Element namespace.</param>
            <param name="name">Element name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Equality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Inequality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Inequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Namespace">
            <summary>
            Gets element namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Name">
            <summary>
            Gets element name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ILogger">
            <summary>
            Engine uses this interface to perform logging.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILogger.LogDebug(System.String)">
            <summary>
            Logs message in debug mode.
            </summary>
            <param name="message">Message to be logged.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILogger.LogError(System.String,System.Exception)">
            <summary>
            Logs message in error mode.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="exception">Exception to be logged.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.ILogger.IsDebugEnabled">
            <summary>
            Determines whether debug mode is enabled.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.ILogger.LogFlags">
            <summary>
            Logging flags.
            </summary>
            <remarks>By default Engine does not log GET response body and PUT request body.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl">
            <summary>
            Default logger implementation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogDebug(System.String)">
            <summary>
            Logs in debug mode.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogError(System.String,System.Exception)">
            <summary>
            Logs message in error mode.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="exception">Exception to be logged.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFile">
            <summary>
            Log file path.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.IsDebugEnabled">
            <summary>
            Determines whether debug mode is enabled.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFlags">
            <summary>
            Logging flags.
            </summary>
            <remarks>By default Engine does not log GET response body and PUT request body.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse">
            Status for an items to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
             Initializes a new instance.
            
             @param itemPath Path of the item in the hierarchy tree.
             @param status WebDAV response for the item.
             @param href href to be included in the response.
             @param responseDescription description of the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Hrefs">
             Hrefs included in the response.
            
             @return path of the item.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Code">
             Gets the response for the item.
            
             @return response for the item
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.MultistatusResponse.AddResponse(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
            <summary>
            Adds new responses to the private collection in this class.
            </summary>
            <param name="path"></param>
            <param name="code"></param>
            <param name="href"></param>
            <param name="responseDescription"></param>   
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStat">
            Status for a number of properties to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.#ctor(System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyValue},ITHit.WebDAV.Server.DavException)">
            Initializes new instance.
            @param property list of properties with the same status.
            @param status status for these properties.
            @param description description.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.Properties">
            Retrieves list of properties with the same status.
            @return list of properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse">
            Response that may be present in multistatus response.
            Describes status of properties relating to the same item.
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.#ctor(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.Impl.Multistatus.PropStat},System.String)">
             Initializes new instance.
            
             @param itemPath    path to item which contains these properties.
             @param propStats   statuses for different properties related to this item.
             @param description description for the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.PropStats">
             Retrieves statuses for properties grouped by item they relate to.
            
             @return statuses for properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.Response">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.Response.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler">
            <summary>
            Summary description for AclDAVHandler.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Determines whether this method shall be enlisted in 'supported-method-set' for 
            <paramref name="item"/>.
            </summary>
            <param name="item">Hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> or <b>null</b>.</param>
            <returns>Boolean indicating whether this handler implementation can handle request for the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.ProcessRequestAsync(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItemAsync)">
            <summary>
            Processes request.
            </summary>
            <param name="context">Instance of context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.</param>
            <param name="item">Hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> or <b>null</b>.</param>
            <remarks>The <see cref="!:IMethodHandler.ProcessRequest"/> method is called by the engine during <see cref="!:DavEngine.Run"/> call. 
            The hierarchy item returned from <see cref="!:DavContextBase.GetHierarchyItem"/> is passed to this method. 
            If <see cref="!:DavContextBase.GetHierarchyItem"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync">
            <summary>
            Implement this interface if your repository will be viewed by Windows Explorer,
            so it is possible to view/modify attributes of files/folders.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync.GetFileAttributesAsync">
            <summary>
            Retrieves file attributes.
            </summary>
            <returns>File attributes.</returns>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public FileAttributes GetFileAttributes()
{
    return fileSystemInfo.Attributes;
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItemAsync.SetFileAttributesAsync(System.IO.FileAttributes)">
            <summary>
            Updates file attributes.
            </summary>
            <param name="value">File attributes.</param>
            <exception cref="!:LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="!:NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="!:InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public void SetFileAttributes(FileAttributes value)
{
    File.SetAttributes(fileSystemInfo.FullName, value);
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.MultistatusException">
            <summary>
            Exception which contains errors for multiple items or properties.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor(System.String)">
            <summary>
            Initializes new message.
            </summary>
            <param name="message">Error text.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with serialized data. 
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the
            exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the
            source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or HResult is zero (0).</exception>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds all errors from <paramref name="mex"/> exception to this one.
            </summary>
            <param name="mex">Exception to merge with.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)">
            <summary>
            Adds item error.
            </summary>
            <param name="itemPath">tem path for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)">
            <summary>
            Addes property error.
            </summary>
            <param name="itemPath">Item path for which property operation failed.</param>
            <param name="propertyName">Property name for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>        
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Whether content shall be written to output.</param>
            <remarks>        
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.RenderInline(System.Xml.XmlTextWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlTextWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">
            <summary>
            Shall be thrown if quota limits are exceeded or there is no physical space left.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.QUOTA_NOT_EXCEEDED">
            <summary>
            Quota was exceeded.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.SUFFICIENT_DISK_SPACE">
            <summary>
            There is insufficient physical space to execute the request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor(System.String,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="message">Error message.</param>
            <param name="reason">One of </param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.IQuotaAsync">
            <summary>
            If your server implementation needs to support quotas, this interface must be
            implemented by collections (items which implement <see cref="!:IFolder"/>, <see cref="!:IPrincipalFolder"/> etc.
            interfaces).
            Optionally this interface can be implemented by other items depending on your requirements.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetAvailableBytesAsync">
            <summary>
            Value in bytes representing the amount of additional disk space beyond the current
            allocation that can be allocated to the folder(or other item) before further
            allocations will be refused.  It is understood that this space may be
            consumed by allocations to other files/folders.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes that can be additionally allocated in folder/file.</returns>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public long GetAvailableBytes()
{
    //Note: Ntfs quotes used retrieval for current user works very slowly, so
    //return disk available space in this sample.
    long freeBytesAvailable = 0;
    long totalNumberOfBytes = 0;
    long totalNumberOfFreeBytes = 0;
    context.FileOperation(
        () => SafeNativeMethods.GetDiskFreeSpaceEx(
            dirInfo.FullName,
            out freeBytesAvailable,
            out totalNumberOfBytes,
            out totalNumberOfFreeBytes));

    return freeBytesAvailable;
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuotaAsync.GetUsedBytesAsync">
            <summary>
             Value in bytes representing the amount of space used by this folder/file
             and possibly a number of other similar folders/files, where the set of "similar" meets at least
             the criterion that allocating space to any folder/file in the set will
             count against the <see cref="!:GetAvailableBytes"/>.  It MUST include the
             total count including usage derived from sub-items if
             appropriate.  It SHOULD include metadata storage size if metadata
             storage is counted against the <see cref="!:GetAvailableBytes"/>
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes occupied by folder/file.</returns>
            <example>
      <para>The code below is part of 'NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public long GetUsedBytes()
{
    // Note: Ntfs quotes used retrieval for current user works very slowly, so
    // return disk used space in this sample.
    long freeBytesAvailable = 0;
    long totalNumberOfBytes = 0;
    long totalNumberOfFreeBytes = 0;
    context.FileOperation(
        () => SafeNativeMethods.GetDiskFreeSpaceEx(
            dirInfo.FullName,
            out freeBytesAvailable,
            out totalNumberOfBytes,
            out totalNumberOfFreeBytes));

    return totalNumberOfBytes - freeBytesAvailable;
}
]]></code>
    </example>
        </member>
    </members>
</doc>
